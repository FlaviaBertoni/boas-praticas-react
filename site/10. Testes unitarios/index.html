<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>10. TESTES UNITARIOS - Boas Práticas React</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "10. TESTES UNITARIOS";
    var mkdocs_page_input_path = "10. Testes unitarios/README.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Boas Práticas React</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../01.%20Como%20se%20manter%20atualizado/">01. COMO SE MANTER ATUALIZADO</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../02.%20Breve%20historia%20do%20react/">02. BREVE HISTORIA DO REACT</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../03.%20Componentes/">03. COMPONENTES</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../07.%20Estilos/">07. ESTILOS</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../09.%20Atomic%20Design/">09. ATOMIC DESIGN</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">10. TESTES UNITARIOS</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#o-que-e-um-teste-unitario-ou-de-unidade">O que é um teste unitário ou de unidade?</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#funcao-dos-testes-unitarios">Função dos testes unitários</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#frameworks-de-teste">Frameworks de teste</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#bibliotecas-de-teste">Bibliotecas de teste</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#enzyme">Enzyme</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#react-testing-library">React Testing Library</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#como-a-biblioteca-rtl-funciona">Como a biblioteca RTL funciona?</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#alem-dos-testes-unitarios">Além dos testes unitários</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#finalizando">Finalizando</a>
    </li>
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Boas Práticas React</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>10. TESTES UNITARIOS</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="testes-unitarios">Testes unitários</h1>
<p><strong>DISCLAIMER:</strong></p>
<p>Vamos assumir que a linguagem de programação é <strong>JavaScript</strong>.</p>
<p>O Framework de teste padrão será o <strong>Jest</strong> e todos os exemplos serão baseados nele, mas vamos falar sobre outros frameworks de teste conhecidos para o JavaScript.</p>
<p>O <em>mindset</em> utilizado será para aplicações <strong>Frontend</strong>.</p>
<h2 id="o-que-e-um-teste-unitario-ou-de-unidade">O que é um teste unitário ou de unidade?</h2>
<p>Por teste unitário ou teste de unidade é entendido que testamos a menor parte <strong>testável</strong> de um software, o que podemos assumir como uma função ou método de uma classe.</p>
<p>Por exemplo, dado a função:</p>
<pre><code class="language-js">function sum(value1, value2) {
  return value1 + value2;
}
</code></pre>
<p>Um teste simples para essa função seria:</p>
<pre><code class="language-js">expect(sum(1, 2)).toEqual(3);
</code></pre>
<p>O exemplo acima é um clássico que você vai poder encontrar por toda internet. Mas para que serve teste unitário? Que dor que o teste resolve? O que devemos testar? Como testar?</p>
<h2 id="funcao-dos-testes-unitarios">Função dos testes unitários</h2>
<p>Os testes unitários nos dão uma vantagem muito maior do que deixar os pequenos pedaços testados e ver o coverage subindo, eles nos dão <strong>confiança</strong>. Confiança que nossa aplicação vai funcionar quando seus usuários a utilizarem.</p>
<p>Outra vantagem dos testes unitários é quando precisamos refatorar.</p>
<p>Já pensou se precisar refatorar a função <strong>sum</strong> para que, internamente, ela fique mais explicita?</p>
<pre><code class="language-js">function sum(value1, value2) {
  const result = value1 + value2;

  return result;
}
</code></pre>
<p>Ou se a gente mudasse de <em>named function</em> para <em>arrow function</em>?</p>
<pre><code class="language-js">const sum = (x, y) =&gt; x + y;
</code></pre>
<p>Refatoramos os <strong>detalhes da implementação</strong> de nossa função, mesmo assim o teste continuaria passando.</p>
<p>Este é o poder dos testes: Nos dar confiança tanto para mudanças tanto para garantir o funcionamento do código em produção.</p>
<h2 id="frameworks-de-teste">Frameworks de teste</h2>
<p>Existem vários framworks de teste para JavaScript, como Cypress, Jasmine, Mocha e Jest.</p>
<p>Quando usamos o Create React App para criar nossa aplicação React, o Jest faz parte do pacote que é instalado pelo CRA.</p>
<p>Jest foi criado pelo Facebook, é um framework que não precisa de muita configuração, uma vez que ele já vem com suporte a mock e sua biblioteca de assersões. Fora isso, é bem documentado e considerado como uma rápido e performático.</p>
<p>Jasmine e Mocha foram (e são) frameworks de teste muito famosos até 2016 segundo o site <a href="https://2020.stateofjs.com/en-US/technologies/testing/">State of JS 2020 survey</a>, porém perderam espaço para o Jest pela facilidade de instalação e configuração.</p>
<p>Já o Cypress é um framwork voltado mais para testes de ponta a ponta, os famosos E2E (end to end) e muito utilizado para validação da UI e fluxos completos. Também é possível realizar testes de integração e até unitários.</p>
<h2 id="bibliotecas-de-teste">Bibliotecas de teste</h2>
<p>Dentre as várias bibliotecas de teste, vamos destacar as duas mais utilizadas hoje no Frontend, principalmente com React: <strong>Enzyme e React Testing Library</strong>.</p>
<p>Tanto Enzyme quanto RTL são "utilitários" que usamos junto ao nosso framework de teste, deixando mais fácil criar testes para nossos componentes construidos com o React. Geralmente essas bibliotecas adicionam formas de manipular e/ou simular eventos como clique e algumas formas de realizar a assersão dos nossos testes.</p>
<p>Nosso foco aqui será com a biblioteca React Testing Library. Não entraremos nos detalhes de configuração inicial de cada biblioteca.</p>
<h3 id="enzyme">Enzyme</h3>
<p>Criada pela equipe da AirBnB que já construiu vários outros componentes para React e também uma Style Guide muito famosa utilizada por muitos Devs quando falamos de desenvolvimento JavaScript / TypeScript.</p>
<p><a href="https://enzymejs.github.io/enzyme/">Na documentação oficial do Enzyme</a>, diz que o Enzyme é um utilitário de testes para o React que torna fácil testar a saída de nossos componentes.</p>
<p>A API do Enzyme é jQuery-like, ou seja, imita a API do jQuery para localizar elementos, disparar eventos com métodos como <code>find()</code> e ainda pondendo buscar elementos por <code>id</code>, <code>name</code> e <code>className</code>, por exemplo.</p>
<p>No Enzyme possuímos basicamente três métodos para renderizar um componente para o teste:</p>
<ul>
<li><strong>mount()</strong></li>
</ul>
<p>Renderiza toda a arvore DOM com todos os childrens e dá a possibilidade de usar toda API do Enzyme simulando cliques, acessando elementos que foram renderizados na DOM e muito mais.</p>
<ul>
<li><strong>shallow()</strong></li>
</ul>
<p>Renderiza somente o componente sem seus filhos e só torna possível simular cliques e outros eventos apenas para o componente renderizado em questão, uma vez que os componentes filhos não são renderizados.</p>
<p>Atualmente a API de Hooks do React <a href="https://enzymejs.github.io/enzyme/#react-hooks-support">não funciona muito bem com shallow rendering</a>.</p>
<ul>
<li><strong>render()</strong></li>
</ul>
<p>Retorna uma string com o código gerado em HTML.</p>
<p>Abaixo, alguns exemplos de testes utilizando Enzyme:</p>
<pre><code class="language-js">import MyComponent from &quot;./MyComponent&quot;;
import Foo from &quot;./Foo&quot;;
import { expect } from &quot;chai&quot;;
import { shallow } from &quot;enzyme&quot;;
import { mount } from &quot;enzyme&quot;;

// Shallow
it(&quot;renders three &lt;Foo /&gt; components&quot;, () =&gt; {
  const wrapper = shallow(&lt;MyComponent /&gt;);
  expect(wrapper.find(Foo)).to.have.lengthOf(3);
});

// Mount
it(&quot;allows us to set props&quot;, () =&gt; {
  const wrapper = mount(&lt;Foo bar=&quot;baz&quot; /&gt;);
  expect(wrapper.props().bar).to.equal(&quot;baz&quot;);
  wrapper.setProps({ bar: &quot;foo&quot; });
  expect(wrapper.props().bar).to.equal(&quot;foo&quot;);
});

// Render
it(&quot;renders three `.foo-bar`s&quot;, () =&gt; {
  const wrapper = render(&lt;Foo /&gt;);
  expect(wrapper.find(&quot;.foo-bar&quot;)).to.have.lengthOf(3);
});
</code></pre>
<h3 id="react-testing-library">React Testing Library</h3>
<blockquote>
<p>The more your tests resemble the way your software is used, the more confidence they can give you. <a href="https://kentcdodds.com/">Kent C. Dodds</a></p>
<p>Quanto mais seus testes se assemelham à forma como o software é usado, mais confiança eles podem lhe dar. <a href="https://translate.google.com/?sl=en&amp;tl=pt&amp;text=The%20more%20your%20tests%20resemble%20the%20way%20your%20software%20is%20used%2C%20the%20more%20confidence%20they%20can%20give%20you.&amp;op=translate">Google Translate</a></p>
</blockquote>
<p>Essa biblioteca para o React faz parte de um conjunto de bibliotecas chamado <strong><a href="https://testing-library.com/">Testing Library</a></strong> que é um utilitário para testes que encoraja boas práticas de teste. Além de React, você pode encontrar para uma série de outras bibliotecas e frameworks como Angular, Vue e Cypress.
React Testing Library foi escrita por <strong><a href="https://kentcdodds.com/">Kent C Dodds</a></strong> que tem apresentado uma outra forma de pensar em testes, principalmente para o Frontend.</p>
<p>A principal ideia dessa biblioteca é que não devemos nos atentar aos detalhes de implementação durante o teste e simplesmente devemos simular o comportamento do usuário exatamente com o que será visto em tela.</p>
<p>Kent escreveu um belo artigo sobre o motivo que <strong><a href="https://kentcdodds.com/blog/testing-implementation-details">detalhes de implementação nos testes são uma receita para o desastre</a></strong>.</p>
<h3 id="como-a-biblioteca-rtl-funciona">Como a biblioteca RTL funciona?</h3>
<p>O <em>mindset</em> dessa biblioteca é de criar testes que se assemelham com o comportamento do usuário da apliação.</p>
<p>O que deve acontecer quando o usuário clicar no botão? O que ele vai ver? Quais elementos estão presentes na tela?</p>
<p>Quando executamos o teste com essa biblioteca o componente sempre será montado com todos os seus filhos e irá se comportar exatamente como se estivesse sendo executado no browser.</p>
<p>E este é o motivo de não precisarmos preocupar com os detalhes de implementação durante o teste. Mesmo que, internamente o componente seja alterado, o teste continuará passando.</p>
<p>Um uso muito importante dessa biblioteca é de trabalharmos com TDD, onde podemos escrever os testes com os resultados esperados e depois ir construindo o componente ir vendo os testes passarem, uma vez que não precisamos nos preocupar com os detalhes da implementação da funcionalidade e isso é muito lindo.</p>
<p>A RTL também sugere fortemente que devemos sempre pensar em acessibilidade e a biblioteca nos fornece uma API para buscar elementos inclusive pela <em><a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles">Role</a></em>. Existe na documentação da Testing Library <a href="https://testing-library.com/docs/queries/about#priority">uma sessão dedicada</a> para explicar os métodos disponíveis pela ordem de prioridade para acessar algum componente ou fazer alguma asserção.</p>
<h2 id="alem-dos-testes-unitarios">Além dos testes unitários</h2>
<p>Segundo a documentação oficial da biblioteca, podemos escrever além dos testes unitários, testes de integração e até mesmo testes de ponta a ponta, os famosos E2E.</p>
<p>Podemos integrar também a bibliteca de asserção com o Cypress e usar os mesmos métodos que utilizamos nos testes unitários com os testes E2E e usando o mesmo mindset de sempre testar o que o usuário está vendo, ou o que realmente ele vai fazer e ver.</p>
<p><img alt="Piramide de testes" src="testing-pyramid.png" /></p>
<p>Essa é a famosa pirâmide de testes adaptada por Kent C. Dodds, evidenciando que, testes unitários são mais baratos e rápidos, então deveríamos gastar mais tempo nos testes unitários, certo?</p>
<p>Segundo Dodds, faltou dizer nessa pirâmide que, quanto mais subimos, aumentamos o coeficiente de confiança para cada forma de teste</p>
<p>Martin Fowler, termina o assunto sobre a pirâmide de testes afirmando o seguinte:
<img alt="Nota de Martin Fowler sobre a pirâmide de testes" src="martin-fowler.jpeg" /></p>
<p>Agora, segundo Kent, nossas ferramentas de teste são incriveis e essa afirmação de Fowler está "menos verdadeira" e então ele mudou o conceito de pirâmide e criou o Troféu dos testes: (<a href="https://twitter.com/kentcdodds/status/1141365123296051201?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1141365123296051201%7Ctwgr%5E%7Ctwcon%5Es1_&amp;ref_url=https%3A%2F%2Fkentcdodds.com%2Fblog%2Fwrite-tests">Confira neste Tweet de Kent</a>)</p>
<p><img alt="Troféu dos testes" src="test_trophy.jpeg" /></p>
<p>De baixo para cima temos:</p>
<ul>
<li><strong>Testes estáticos (Static):</strong></li>
</ul>
<p>Utilizamos com ferramentas como ESLint ou com TypeScript que consegue pegar erros de Typos e regras bem mais rápido do que num Code Review. A analize é realizada enquanto estamos digitando o código.</p>
<ul>
<li><strong>Testes unitários (Unit):</strong></li>
</ul>
<p>Verifica se, individualmente e isoladas, as partes funcionam como esperado.</p>
<ul>
<li><strong>Testes de integração (Integration):</strong></li>
</ul>
<p>Verifica se as partes funcionam em harmonia quando estão juntas.</p>
<p>Também chamado as vezes de teste de componente.</p>
<ul>
<li><strong>Testes de ponta a ponta (End to End):</strong></li>
</ul>
<p>Se comporta como um usuário usando a aplicação para verificar se tudo está funcionando corretamente. Tambem chamado as vezes de Teste funcional (Functional testing) ou e2e.</p>
<p>Segundo o Troféu dos testes, devemos ter mais testes de integração do que unitários e isso se dá muitas vezes porque não temos como ou não vale a pena testar de forma isolada um componente de UI, como um botão ou um input estilizado, por exemplo.</p>
<p>Pense: Não importa quantas propriedades o componente de botão ou input recebem. É bom, se for possível, testá-los isoladamente, mas testar integrados com uma página onde os botões e o input realmente serão utilizados vai nos dar muito mais confiança nos testes e quem sabe até nem precisaríamos nos preocupar com os testes unitários para esses componentes, hein?</p>
<p>Talvez poderíamos passar mais tempo escrevendo testes de integração e criando menos mocks porque hoje eles seriam uma balança perfeita entre confiança e velocidade/custo de desenvolvimento.</p>
<h2 id="finalizando">Finalizando</h2>
<p>O assunto sobre testes é de fato cheio de polêmicas.</p>
<p>A linha que divide o que é cada tipo de teste, saber o que testar, quando testar e qual ferramenta usar é muito tênue e tudo isso gera muita dúvida e muita discussão.</p>
<p>O fato é que os testes devem nos dar <strong>confiança</strong> para fazermos as alterações que precisarmos em nossa aplicação e garantindo que a aplicação continuará funcionando em produção.</p>
<p>Não há dúvidas que essa é a essência do teste de software.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../09.%20Atomic%20Design/" class="btn btn-neutral" title="09. ATOMIC DESIGN"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../09.%20Atomic%20Design/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
