{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"boas-praticas-react Material de apoio sobre Boas Pr\u00e1ticas na implementa\u00e7\u00e3o de aplica\u00e7\u00f5es utilizando React.js e React Native. github T\u00f3picos React.js Como se manter atualizado Breve hist\u00f3ria do react (o que resolve, diferen\u00e7as principais das vers\u00f5es 15 e > 16.8 (render, classes, hooks), \u00e9 uma lib) 2.1. DOM e Virtual DOM 2.2. JSX - https://reactjs.org/ e https://babeljs.io/repl Componentes 3.1. Class Component e Function Component 3.2. Componentes Puros Estado 4.1. Componentes stateful e stateless 4.2. Estado do componente 4.3. Estado da aplica\u00e7\u00e3o (flux, redux, effector, hooks, context) Hooks (useState, useEffect, exemplo de custom hook - sess\u00e3o usu\u00e1rio) Context (global) Props (proptypes / typescript - comunica\u00e7\u00e3o entre componentes - fluxo, children) Refs (perigoso) Estilos Estrutura de projetos mais populares (container, index, service) Atomic Design Testes unit\u00e1rios React Native Style Estrutura","title":"Home"},{"location":"#boas-praticas-react","text":"Material de apoio sobre Boas Pr\u00e1ticas na implementa\u00e7\u00e3o de aplica\u00e7\u00f5es utilizando React.js e React Native. github","title":"boas-praticas-react"},{"location":"#topicos","text":"","title":"T\u00f3picos"},{"location":"#reactjs","text":"Como se manter atualizado Breve hist\u00f3ria do react (o que resolve, diferen\u00e7as principais das vers\u00f5es 15 e > 16.8 (render, classes, hooks), \u00e9 uma lib) 2.1. DOM e Virtual DOM 2.2. JSX - https://reactjs.org/ e https://babeljs.io/repl Componentes 3.1. Class Component e Function Component 3.2. Componentes Puros Estado 4.1. Componentes stateful e stateless 4.2. Estado do componente 4.3. Estado da aplica\u00e7\u00e3o (flux, redux, effector, hooks, context) Hooks (useState, useEffect, exemplo de custom hook - sess\u00e3o usu\u00e1rio) Context (global) Props (proptypes / typescript - comunica\u00e7\u00e3o entre componentes - fluxo, children) Refs (perigoso) Estilos Estrutura de projetos mais populares (container, index, service) Atomic Design Testes unit\u00e1rios","title":"React.js"},{"location":"#react-native","text":"Style Estrutura","title":"React Native"},{"location":"01.%20Como%20se%20manter%20atualizado/","text":"React.js Desde as vers\u00f5es 0.* at\u00e9 a 17 tiveram diversas mudan\u00e7as em como se escreve o c\u00f3digo usando react.js que consequentemente impactaram nos padr\u00f5es e boas pr\u00e1ticas, por isso o primeiro t\u00f3pico ser\u00e1 sobre alguns links que ajudam a se manter atualizado: Como se manter atualizado Documenta\u00e7\u00e3o oficial : a melhor refer\u00eancia quando se trata de programa\u00e7\u00e3o, por\u00e9m n\u00e3o s\u00e3o todos os exemplos dela que est\u00e3o sempre atualizados com as mudan\u00e7as mais recentes, atualmente por exemplo existem diversos exemplos no site que n\u00e3o cont\u00eam os hooks e componentes escritos como fun\u00e7\u00f5es, por\u00e9m a comunidade est\u00e1 cada vez mais adotando essas novas funcionalidades e deixando de usar as classes. Pensando em React : recomendo para entender conceitualmente como escrever aplica\u00e7\u00f5es em react. Create react app : uma das toolchains mais utilizadas para come\u00e7ar a desenvolver usando react.js, costuma estar bem atualizada e com diversas configura\u00e7\u00f5es \u00fateis para o desenvolvimento local e build para produ\u00e7\u00e3o. Ent\u00e3o \u00e9 legal acompanhar as novas vers\u00f5es olhando para o que est\u00e1 sendo adicionado e porqu\u00ea. Outras toolchais recomendadas pelo React : \u00e9 bom ver tamb\u00e9m outras toolchains que o react recomenda, para conhecer as novas solu\u00e7\u00f5es que est\u00e3o surgindo para os problemas que voc\u00ea pode encontrar no seu projeto. Changelog : \u00e9 sempre bom acompanhar o que muda em cada vers\u00e3o do react e para isso o changelog \u00e9 extremamente \u00fatil! Mantenha-se Informado : nesse link voc\u00ea vai encontrar as dicas do pr\u00f3prio react para se manter atualizado :) Outros links legais para conhecer: Medium React Brasil ReactJS Github Rocketseat blog e canal no youtube Material-ui","title":"01. COMO SE MANTER ATUALIZADO"},{"location":"01.%20Como%20se%20manter%20atualizado/#reactjs","text":"Desde as vers\u00f5es 0.* at\u00e9 a 17 tiveram diversas mudan\u00e7as em como se escreve o c\u00f3digo usando react.js que consequentemente impactaram nos padr\u00f5es e boas pr\u00e1ticas, por isso o primeiro t\u00f3pico ser\u00e1 sobre alguns links que ajudam a se manter atualizado:","title":"React.js"},{"location":"01.%20Como%20se%20manter%20atualizado/#como-se-manter-atualizado","text":"Documenta\u00e7\u00e3o oficial : a melhor refer\u00eancia quando se trata de programa\u00e7\u00e3o, por\u00e9m n\u00e3o s\u00e3o todos os exemplos dela que est\u00e3o sempre atualizados com as mudan\u00e7as mais recentes, atualmente por exemplo existem diversos exemplos no site que n\u00e3o cont\u00eam os hooks e componentes escritos como fun\u00e7\u00f5es, por\u00e9m a comunidade est\u00e1 cada vez mais adotando essas novas funcionalidades e deixando de usar as classes. Pensando em React : recomendo para entender conceitualmente como escrever aplica\u00e7\u00f5es em react. Create react app : uma das toolchains mais utilizadas para come\u00e7ar a desenvolver usando react.js, costuma estar bem atualizada e com diversas configura\u00e7\u00f5es \u00fateis para o desenvolvimento local e build para produ\u00e7\u00e3o. Ent\u00e3o \u00e9 legal acompanhar as novas vers\u00f5es olhando para o que est\u00e1 sendo adicionado e porqu\u00ea. Outras toolchais recomendadas pelo React : \u00e9 bom ver tamb\u00e9m outras toolchains que o react recomenda, para conhecer as novas solu\u00e7\u00f5es que est\u00e3o surgindo para os problemas que voc\u00ea pode encontrar no seu projeto. Changelog : \u00e9 sempre bom acompanhar o que muda em cada vers\u00e3o do react e para isso o changelog \u00e9 extremamente \u00fatil! Mantenha-se Informado : nesse link voc\u00ea vai encontrar as dicas do pr\u00f3prio react para se manter atualizado :) Outros links legais para conhecer: Medium React Brasil ReactJS Github Rocketseat blog e canal no youtube Material-ui","title":"Como se manter atualizado"},{"location":"02.%20Breve%20historia%20do%20react/","text":"Breve hist\u00f3ria do React O React \u00e9 uma biblioteca JavaScript open-source para constru\u00e7\u00e3o de interfaces de usu\u00e1rio que foi desenvolvido inicalmente pelo Facebook a fim de resolver os problemas de atualiza\u00e7\u00e3o no DOM e hoje \u00e9 mantida tamb\u00e9m pela comunidade. Em 2013 o Facebook precisava de uma forma mais simples e r\u00e1pida de manter suas funcionalidades din\u00e2micas, assim era necess\u00e1rio que o conte\u00fado apresentado no HTML mudasse de forma reativa. Outra vantagem do React \u00e9 a ideia de criar sua aplica\u00e7\u00e3o separada em componentes, facilitando na escalada da mesma. Algumas diferen\u00e7as em como se criavam os componentes: Vers\u00e3o Implementa\u00e7\u00e3o 0.3.0 (Maio, 2013) React.createClass({ render() {}}) 0.10.* (2014/2015) class MeuComponente extends React.Component { render() {} } 0.14.0 (Outubro, 2015) function MeuComponent { return (</div>)} Pra ver mais mudan\u00e7as entre as vers\u00f5es verifique o changelog Outras diferen\u00e7a marcante foi no estado e clicos de vida, como por exemplo: class MeuComponente extends React.Component { constructor(props) { super(props); this.state = { status: '' }; } componentDidMount() { this.setState(state => ({ status: 'mounted' })); } componentWillUnmount() { alert('unmounted'); } render() { return ( <h1> React {this.state.status} </h1> ); } } E em Fevereiro de 2019 foi lan\u00e7ada a vers\u00e3o 16.8 que apresentou os React Hooks, mudando bastante a forma como se pode trabalhar com estado e side effects: function MeuComponente() { const [status, setStatus] = useState(''); useEffect(() => { setStatus('mounted'); return () => { alert('unmounted') } }); return ( <h1> React {status} </h1> ); } Exemplo em a\u00e7\u00e3o DOM e Virtual DOM O DOM (Document Object Model) \u00e9 uma interface que representa como os documentos HTML e XML s\u00e3o lidos pelo brower. A maneira mais f\u00e1cial e corriqueira de se alterar um elemento da p\u00e1gina pelo javascript \u00e9 manipulando a DOM. <html> <head> <title>My Document</title> </head> <body> <h1>Header</h1> <p>Paragraph</p> </body> </html> // document.getElementsByTagName(\"H1\") retorna um NodeList dos elementos H1 // no documento, e o primeiro \u00e9 o n\u00famero 0: var header = document.getElementsByTagName(\"H1\").item(0); // o firstChild do cabe\u00e7alho \u00e9 um Text node, e a propriedade data // do text node cont\u00e9m seu texto: header.firstChild.data = \"A dynamic document\"; // agora o cabe\u00e7alho \u00e9 \"A dynamic document\". // Recupera o primeiro elemento P no documento do mesmo modo: var para = document.getElementsByTagName(\"P\").item(0); // e altera seu texto tamb\u00e9m: para.firstChild.data = \"This is the first paragraph.\"; // cria um novo Text node para o segundo par\u00e1grafo var newText = document.createTextNode(\"This is the second paragraph.\"); // cria um novo Element para ser o segundo par\u00e1grafo var newElement = document.createElement(\"P\"); // insere o texto no segundo par\u00e1grafo newElement.appendChild(newText); // e coloca o par\u00e1grafo no final do documento acrescentando-o ao // BODY (que \u00e9 o pai de para) para.parentNode.appendChild(newElement); Exemplo em a\u00e7\u00e3o * Para saber mais sobre como o DOM funcioan recomendo a leitura no MDN Como manipular o DOM pode ser um processo meio demorado, bibliotecas como o React, implementaram o conceito de Virtual DOM , que \u00e9 nada mais do que a representa\u00e7\u00e3o do DOM em mem\u00f3ria. Com isso, quando alguma parte do HTML precisa ser atualizado, a biblioteca faz toda esta manipula\u00e7\u00e3o no Virtual DOM, compara com o DOM e s\u00f3 altera o estritamente necess\u00e1rio, economizando processamento. JSX O JSX \u00e9 uma extens\u00e3o de sintaxe para JavaScript que lembra uma linguagem de Templates, como o HTML ou XML. Como podemos ver no c\u00f3digo abaixo, temos uma sintaxe que se parece com uma mescla entre JavaScript e HTML. const element = <h1>Hello, world!</h1> ReactDOM.render(element, document.getElementById('root')) Apesar de ser extremamente recomendado o uso de JSX com React, seu uso n\u00e3o \u00e9 obrigat\u00f3rio. O mesmo c\u00f3digo acima, pode ser escrito da seguinte maneira: const element = React.createElement(\"<h1>\", null, \"Hello, world!\"); ReactDOM.render(element, document.getElementById('root')) Vantagens em utilizar JSX com React Garante maior legibilidade do c\u00f3digo Uma vez que a sintaxe se parece com uma linguagem de Template, fica visualmente mais organizado e mais f\u00e1cil de entender sua estrutura. Otimiza o c\u00f3digo ao \"compilar\" O JSX \u00e9 transpilado por motores, como o babel , para javascript puro, de maneira que o browser consiga interpreta-lo. Previne injection Por padr\u00e3o, o React DOM escapa quaisquer valores incorporados no JSX antes de renderiz\u00e1-los. Assim, assegura que voc\u00ea nunca injete algo que n\u00e3o esteja explicitamente escrito na sua aplica\u00e7\u00e3o. Tudo \u00e9 convertido para string antes de ser renderizado. Isso ajuda a prevenir ataques XSS (cross-site-scripting). Aten\u00e7\u00e3o: Como JSX \u00e9 mais pr\u00f3ximo de JavaScript que do HTML, o React DOM usa camelCase como conven\u00e7\u00e3o para nomes de propriedades ao inv\u00e9s dos nomes de atributos do HTML. Por exemplo, class se transforma em className em JSX, e tabindex se transforma em tabIndex.","title":"02. BREVE HISTORIA DO REACT"},{"location":"02.%20Breve%20historia%20do%20react/#breve-historia-do-react","text":"O React \u00e9 uma biblioteca JavaScript open-source para constru\u00e7\u00e3o de interfaces de usu\u00e1rio que foi desenvolvido inicalmente pelo Facebook a fim de resolver os problemas de atualiza\u00e7\u00e3o no DOM e hoje \u00e9 mantida tamb\u00e9m pela comunidade. Em 2013 o Facebook precisava de uma forma mais simples e r\u00e1pida de manter suas funcionalidades din\u00e2micas, assim era necess\u00e1rio que o conte\u00fado apresentado no HTML mudasse de forma reativa. Outra vantagem do React \u00e9 a ideia de criar sua aplica\u00e7\u00e3o separada em componentes, facilitando na escalada da mesma. Algumas diferen\u00e7as em como se criavam os componentes: Vers\u00e3o Implementa\u00e7\u00e3o 0.3.0 (Maio, 2013) React.createClass({ render() {}}) 0.10.* (2014/2015) class MeuComponente extends React.Component { render() {} } 0.14.0 (Outubro, 2015) function MeuComponent { return (</div>)} Pra ver mais mudan\u00e7as entre as vers\u00f5es verifique o changelog Outras diferen\u00e7a marcante foi no estado e clicos de vida, como por exemplo: class MeuComponente extends React.Component { constructor(props) { super(props); this.state = { status: '' }; } componentDidMount() { this.setState(state => ({ status: 'mounted' })); } componentWillUnmount() { alert('unmounted'); } render() { return ( <h1> React {this.state.status} </h1> ); } } E em Fevereiro de 2019 foi lan\u00e7ada a vers\u00e3o 16.8 que apresentou os React Hooks, mudando bastante a forma como se pode trabalhar com estado e side effects: function MeuComponente() { const [status, setStatus] = useState(''); useEffect(() => { setStatus('mounted'); return () => { alert('unmounted') } }); return ( <h1> React {status} </h1> ); } Exemplo em a\u00e7\u00e3o","title":"Breve hist\u00f3ria do React"},{"location":"02.%20Breve%20historia%20do%20react/#dom-e-virtual-dom","text":"O DOM (Document Object Model) \u00e9 uma interface que representa como os documentos HTML e XML s\u00e3o lidos pelo brower. A maneira mais f\u00e1cial e corriqueira de se alterar um elemento da p\u00e1gina pelo javascript \u00e9 manipulando a DOM. <html> <head> <title>My Document</title> </head> <body> <h1>Header</h1> <p>Paragraph</p> </body> </html> // document.getElementsByTagName(\"H1\") retorna um NodeList dos elementos H1 // no documento, e o primeiro \u00e9 o n\u00famero 0: var header = document.getElementsByTagName(\"H1\").item(0); // o firstChild do cabe\u00e7alho \u00e9 um Text node, e a propriedade data // do text node cont\u00e9m seu texto: header.firstChild.data = \"A dynamic document\"; // agora o cabe\u00e7alho \u00e9 \"A dynamic document\". // Recupera o primeiro elemento P no documento do mesmo modo: var para = document.getElementsByTagName(\"P\").item(0); // e altera seu texto tamb\u00e9m: para.firstChild.data = \"This is the first paragraph.\"; // cria um novo Text node para o segundo par\u00e1grafo var newText = document.createTextNode(\"This is the second paragraph.\"); // cria um novo Element para ser o segundo par\u00e1grafo var newElement = document.createElement(\"P\"); // insere o texto no segundo par\u00e1grafo newElement.appendChild(newText); // e coloca o par\u00e1grafo no final do documento acrescentando-o ao // BODY (que \u00e9 o pai de para) para.parentNode.appendChild(newElement); Exemplo em a\u00e7\u00e3o * Para saber mais sobre como o DOM funcioan recomendo a leitura no MDN Como manipular o DOM pode ser um processo meio demorado, bibliotecas como o React, implementaram o conceito de Virtual DOM , que \u00e9 nada mais do que a representa\u00e7\u00e3o do DOM em mem\u00f3ria. Com isso, quando alguma parte do HTML precisa ser atualizado, a biblioteca faz toda esta manipula\u00e7\u00e3o no Virtual DOM, compara com o DOM e s\u00f3 altera o estritamente necess\u00e1rio, economizando processamento.","title":"DOM e Virtual DOM"},{"location":"02.%20Breve%20historia%20do%20react/#jsx","text":"O JSX \u00e9 uma extens\u00e3o de sintaxe para JavaScript que lembra uma linguagem de Templates, como o HTML ou XML. Como podemos ver no c\u00f3digo abaixo, temos uma sintaxe que se parece com uma mescla entre JavaScript e HTML. const element = <h1>Hello, world!</h1> ReactDOM.render(element, document.getElementById('root')) Apesar de ser extremamente recomendado o uso de JSX com React, seu uso n\u00e3o \u00e9 obrigat\u00f3rio. O mesmo c\u00f3digo acima, pode ser escrito da seguinte maneira: const element = React.createElement(\"<h1>\", null, \"Hello, world!\"); ReactDOM.render(element, document.getElementById('root'))","title":"JSX"},{"location":"02.%20Breve%20historia%20do%20react/#vantagens-em-utilizar-jsx-com-react","text":"Garante maior legibilidade do c\u00f3digo Uma vez que a sintaxe se parece com uma linguagem de Template, fica visualmente mais organizado e mais f\u00e1cil de entender sua estrutura. Otimiza o c\u00f3digo ao \"compilar\" O JSX \u00e9 transpilado por motores, como o babel , para javascript puro, de maneira que o browser consiga interpreta-lo. Previne injection Por padr\u00e3o, o React DOM escapa quaisquer valores incorporados no JSX antes de renderiz\u00e1-los. Assim, assegura que voc\u00ea nunca injete algo que n\u00e3o esteja explicitamente escrito na sua aplica\u00e7\u00e3o. Tudo \u00e9 convertido para string antes de ser renderizado. Isso ajuda a prevenir ataques XSS (cross-site-scripting). Aten\u00e7\u00e3o: Como JSX \u00e9 mais pr\u00f3ximo de JavaScript que do HTML, o React DOM usa camelCase como conven\u00e7\u00e3o para nomes de propriedades ao inv\u00e9s dos nomes de atributos do HTML. Por exemplo, class se transforma em className em JSX, e tabindex se transforma em tabIndex.","title":"Vantagens em utilizar JSX com React"},{"location":"03.%20Componentes/","text":"Componentes Componentes React s\u00e3o como fun\u00e7\u00f5es JavaScript. Eles aceitam entradas como propriedades (chamadas \u201cprops\u201d) e retornam novos elementos React (JSX). Os componentes permitem que a UI seja dividida em partes independentes e reutiliz\u00e1veis, ou seja, trata cada parte da aplica\u00e7\u00e3o como um bloco isolado, livre de outras depend\u00eancias externas. Class Component e Function Component A maneira mais simples de definir um componente \u00e9 escrever uma fun\u00e7\u00e3o JavaScript: function Welcome(props) { return <h1>Ol\u00e1, {props.name}</h1>; }; Este mesmo exemplo pode ser escrito em forma de Classe ES6: class Wellcome extends React.Component { render() { return <h1>Ol\u00e1, {this.props.name}</h1>; } } Para o React, estes dois componentes s\u00e3o equivalentes. Antes da vers\u00e3o 16.8 do react utillizava-se classes para componentes que precisavem guardar seu estado (stateful) e fun\u00e7\u00f5es para componente que n\u00e3o utiliza estado (stateless) A partir da vers\u00e3o 16.8, com a vinda dos Hooks , esta separa\u00e7\u00e3o n\u00e3o \u00e9 mais necess\u00e1ria, ou seja, conseguimos criar componentes statful e stataless tanto com classe quanto com fun\u00e7\u00f5es . Hoje em dia, a recomenda\u00e7\u00e3o \u00e9 que se utilize Function Components ao inv\u00e9s de Class Components. Renderizando um Componente O exemplo assim pode ser renderizado da seguinte maneira: function Welcome(props) { return <h1>Ol\u00e1, {props.name}!</h1>; } const element = <Welcome name=\"Carla\" />; ReactDOM.render(element, document.getElementById('root')); Sa\u00edda: Ol\u00e1, Carla! Aten\u00e7\u00e3o Sempre inicie os nomes dos componentes com letra mai\u00fascula. No React, componente que come\u00e7am com letra min\u00fascula s\u00e3o tags do DOM. O <div /> representa a tag div do HTML, por\u00e9m o <Welcome /> representa o componente Welcome que acabamos de criar. Passando informa\u00e7\u00f5es para um componente A maneira de passar informa\u00e7\u00f5es para um componente \u00e9 atrav\u00e9s de suas propriedades (props). Props s\u00e3o somente leitura Um componente nunca deve modificar seus pr\u00f3prios props Compondo Componentes A composi\u00e7\u00e3o \u00e9 a base da reutiliza\u00e7\u00e3o de componentes de UI. O React permite compor facilmente os componentes React existentes, juntamente com elementos HTML nativos, para desenvolver componentes mais complexos. const Welcome = (props) => <h1>Ol\u00e1, {props.name}</h1>; function App() { return ( <div> <Welcome name=\"Carla\" /> <Welcome name=\"Julia\" /> <Welcome name=\"Amanda\" /> </div> ); } ReactDOM.render(<App />, document.getElementById('root')); Extraindo Componentes Uma boa pr\u00e1tica que devemos adotar no React \u00e9 a de construir componentes pequenos. Para exemplificar vamos pegar o componente Comment , abaixo, que descreve um coment\u00e1rio em uma rede social. Ele tem como entrada (props): author (objeto) text (string) date (data) function Comment(props) { return ( <div className=\"Comment\"> <div className=\"UserInfo\"> <img className=\"Avatar\" src={props.author.avatarUrl} alt={props.author.name} /> <div className=\"UserInfo-name\"> {props.author.name} </div> </div> <div className=\"Comment-text\"> {props.text} </div> <div className=\"Comment-date\"> {formatDate(props.date)} </div> </div> ); } Podemos ver que este \u00e9 um componente complicado de alterar, por conta de todo o aninhamento. Tamb\u00e9m \u00e9 dif\u00edcil reutilizar suas partes individuais. Extraindo o Avatar function Avatar(props) { return ( <img className=\"Avatar\" src={props.user.avatarUrl} alt={props.user.name} /> ) } function Comment(props) { return ( <div className=\"Comment\"> <div className=\"UserInfo\"> <Avatar user={props.author} /> <div className=\"UserInfo-name\"> {props.author.name} </div> </div> <div className=\"Comment-text\"> {props.text} </div> <div className=\"Comment-date\"> {formatDate(props.date)} </div> </div> ); } Vamos extrair o UserInfo function Avatar(props) { return ( <img className=\"Avatar\" src={props.user.avatarUrl} alt={props.user.name} /> ) } function UserInfo(props) { return ( <div className=\"UserInfo\"> <Avatar user={props.user} /> <div className=\"UserInfo-name\"> {props.user.name} </div> </div> ) } function Comment(props) { return ( <div className=\"Comment\"> <UserInfo user={props.author}> <div className=\"Comment-text\"> {props.text} </div> <div className=\"Comment-date\"> {formatDate(props.date)} </div> </div> ); } Com isso o componente fica com uma leitura mais simples, reutilizavel e com uma melhor manutenabilidade. Componentes Puros O React.PureComponent \u00e9 similar ao React.Component , por\u00e9m ele faz um tratamento diferente no momento da renderiza\u00e7\u00e3o do componente. No momento da renderiza\u00e7\u00e3o, o PureComponent faz uma chamada ao m\u00e9todo shouldComponentUpdate() que compara os objetos (props e states) de forma superficial e s\u00f3 renderiza se houver alguma altera\u00e7\u00e3o. Aten\u00e7\u00e3o O m\u00e9todo shouldComponentUpdate() do React.PureComponent compara os objetos apenas superficialmente. Se eles contiverem estruturas de dados complexas, isto pode causar falso-negativos para diferen\u00e7as mais profundas. Estenda PureComponent quando voc\u00ea espera possuir props e state simples Al\u00e9m disso, o m\u00e9todo shouldComponentUpdate() do React.PureComponent pula atualiza\u00e7\u00f5es de prop para toda a sub\u00e1rvore do componente. Esteja certo de que todos seus componentes que descendem dele tamb\u00e9m s\u00e3o \u201cpuros\u201d. React.Memo Como vimos na se\u00e7\u00e3o anterior, o PureComponent \u00e9 uma extens\u00e3o de classe que tem o comportamento de verificar se houve mudan\u00e7a no State ou Props e s\u00f3 atualiza o quando \u00e9 identificada a altera\u00e7\u00e3o. Por\u00e9m como este comportamento \u00e9 controlado quando utilizamos Function Componente? A resposta para esta pergunta \u00e9 o React.Memo! O React.Memo \u00e9 um super componente que verifica se houve altera\u00e7\u00e3o nas Props antes de fazer a atuliza\u00e7\u00e3o do componente renderizado.","title":"03. COMPONENTES"},{"location":"03.%20Componentes/#componentes","text":"Componentes React s\u00e3o como fun\u00e7\u00f5es JavaScript. Eles aceitam entradas como propriedades (chamadas \u201cprops\u201d) e retornam novos elementos React (JSX). Os componentes permitem que a UI seja dividida em partes independentes e reutiliz\u00e1veis, ou seja, trata cada parte da aplica\u00e7\u00e3o como um bloco isolado, livre de outras depend\u00eancias externas.","title":"Componentes"},{"location":"03.%20Componentes/#class-component-e-function-component","text":"A maneira mais simples de definir um componente \u00e9 escrever uma fun\u00e7\u00e3o JavaScript: function Welcome(props) { return <h1>Ol\u00e1, {props.name}</h1>; }; Este mesmo exemplo pode ser escrito em forma de Classe ES6: class Wellcome extends React.Component { render() { return <h1>Ol\u00e1, {this.props.name}</h1>; } } Para o React, estes dois componentes s\u00e3o equivalentes. Antes da vers\u00e3o 16.8 do react utillizava-se classes para componentes que precisavem guardar seu estado (stateful) e fun\u00e7\u00f5es para componente que n\u00e3o utiliza estado (stateless) A partir da vers\u00e3o 16.8, com a vinda dos Hooks , esta separa\u00e7\u00e3o n\u00e3o \u00e9 mais necess\u00e1ria, ou seja, conseguimos criar componentes statful e stataless tanto com classe quanto com fun\u00e7\u00f5es . Hoje em dia, a recomenda\u00e7\u00e3o \u00e9 que se utilize Function Components ao inv\u00e9s de Class Components.","title":"Class Component e Function Component"},{"location":"03.%20Componentes/#renderizando-um-componente","text":"O exemplo assim pode ser renderizado da seguinte maneira: function Welcome(props) { return <h1>Ol\u00e1, {props.name}!</h1>; } const element = <Welcome name=\"Carla\" />; ReactDOM.render(element, document.getElementById('root')); Sa\u00edda: Ol\u00e1, Carla! Aten\u00e7\u00e3o Sempre inicie os nomes dos componentes com letra mai\u00fascula. No React, componente que come\u00e7am com letra min\u00fascula s\u00e3o tags do DOM. O <div /> representa a tag div do HTML, por\u00e9m o <Welcome /> representa o componente Welcome que acabamos de criar.","title":"Renderizando um Componente"},{"location":"03.%20Componentes/#passando-informacoes-para-um-componente","text":"A maneira de passar informa\u00e7\u00f5es para um componente \u00e9 atrav\u00e9s de suas propriedades (props). Props s\u00e3o somente leitura Um componente nunca deve modificar seus pr\u00f3prios props","title":"Passando informa\u00e7\u00f5es para um componente"},{"location":"03.%20Componentes/#compondo-componentes","text":"A composi\u00e7\u00e3o \u00e9 a base da reutiliza\u00e7\u00e3o de componentes de UI. O React permite compor facilmente os componentes React existentes, juntamente com elementos HTML nativos, para desenvolver componentes mais complexos. const Welcome = (props) => <h1>Ol\u00e1, {props.name}</h1>; function App() { return ( <div> <Welcome name=\"Carla\" /> <Welcome name=\"Julia\" /> <Welcome name=\"Amanda\" /> </div> ); } ReactDOM.render(<App />, document.getElementById('root'));","title":"Compondo Componentes"},{"location":"03.%20Componentes/#extraindo-componentes","text":"Uma boa pr\u00e1tica que devemos adotar no React \u00e9 a de construir componentes pequenos. Para exemplificar vamos pegar o componente Comment , abaixo, que descreve um coment\u00e1rio em uma rede social. Ele tem como entrada (props): author (objeto) text (string) date (data) function Comment(props) { return ( <div className=\"Comment\"> <div className=\"UserInfo\"> <img className=\"Avatar\" src={props.author.avatarUrl} alt={props.author.name} /> <div className=\"UserInfo-name\"> {props.author.name} </div> </div> <div className=\"Comment-text\"> {props.text} </div> <div className=\"Comment-date\"> {formatDate(props.date)} </div> </div> ); } Podemos ver que este \u00e9 um componente complicado de alterar, por conta de todo o aninhamento. Tamb\u00e9m \u00e9 dif\u00edcil reutilizar suas partes individuais. Extraindo o Avatar function Avatar(props) { return ( <img className=\"Avatar\" src={props.user.avatarUrl} alt={props.user.name} /> ) } function Comment(props) { return ( <div className=\"Comment\"> <div className=\"UserInfo\"> <Avatar user={props.author} /> <div className=\"UserInfo-name\"> {props.author.name} </div> </div> <div className=\"Comment-text\"> {props.text} </div> <div className=\"Comment-date\"> {formatDate(props.date)} </div> </div> ); } Vamos extrair o UserInfo function Avatar(props) { return ( <img className=\"Avatar\" src={props.user.avatarUrl} alt={props.user.name} /> ) } function UserInfo(props) { return ( <div className=\"UserInfo\"> <Avatar user={props.user} /> <div className=\"UserInfo-name\"> {props.user.name} </div> </div> ) } function Comment(props) { return ( <div className=\"Comment\"> <UserInfo user={props.author}> <div className=\"Comment-text\"> {props.text} </div> <div className=\"Comment-date\"> {formatDate(props.date)} </div> </div> ); } Com isso o componente fica com uma leitura mais simples, reutilizavel e com uma melhor manutenabilidade.","title":"Extraindo Componentes"},{"location":"03.%20Componentes/#componentes-puros","text":"O React.PureComponent \u00e9 similar ao React.Component , por\u00e9m ele faz um tratamento diferente no momento da renderiza\u00e7\u00e3o do componente. No momento da renderiza\u00e7\u00e3o, o PureComponent faz uma chamada ao m\u00e9todo shouldComponentUpdate() que compara os objetos (props e states) de forma superficial e s\u00f3 renderiza se houver alguma altera\u00e7\u00e3o. Aten\u00e7\u00e3o O m\u00e9todo shouldComponentUpdate() do React.PureComponent compara os objetos apenas superficialmente. Se eles contiverem estruturas de dados complexas, isto pode causar falso-negativos para diferen\u00e7as mais profundas. Estenda PureComponent quando voc\u00ea espera possuir props e state simples Al\u00e9m disso, o m\u00e9todo shouldComponentUpdate() do React.PureComponent pula atualiza\u00e7\u00f5es de prop para toda a sub\u00e1rvore do componente. Esteja certo de que todos seus componentes que descendem dele tamb\u00e9m s\u00e3o \u201cpuros\u201d.","title":"Componentes Puros"},{"location":"03.%20Componentes/#reactmemo","text":"Como vimos na se\u00e7\u00e3o anterior, o PureComponent \u00e9 uma extens\u00e3o de classe que tem o comportamento de verificar se houve mudan\u00e7a no State ou Props e s\u00f3 atualiza o quando \u00e9 identificada a altera\u00e7\u00e3o. Por\u00e9m como este comportamento \u00e9 controlado quando utilizamos Function Componente? A resposta para esta pergunta \u00e9 o React.Memo! O React.Memo \u00e9 um super componente que verifica se houve altera\u00e7\u00e3o nas Props antes de fazer a atuliza\u00e7\u00e3o do componente renderizado.","title":"React.Memo"},{"location":"07.%20Estilos/","text":"Estilos Atualmente a biblioteca React n\u00e3o tem nenhuma opini\u00e3o sobre como estilos s\u00e3o definidos. Voc\u00ea pode criar estilos da maneira que achar melhor. React aceita tanto inline styles, quanto adicionando classes e os famosos CSS-in-JS. Inline Styles Para se usar CSS inline com React (JSX), deve se usar um objeto ao inv\u00e9s de string como no HTML puro. Os atributos precisam estar no padr\u00e3o camelCase e separados por virgula. Exatamente como num objeto JS comum. function ColorBlock() { const style = { margin: \"20px\", width: \"250px\", height: \"250px\", backgroundColor: \"yellow\", }; return <div style={styles}>...</div>; } function ColorBlock() { return ( <div style={{ backgroundColor: \"red\", width: \"100px\", height: \"100px\" }}> ... </div> ); } const Button = ({ green }) => { return ( <button style={{ width: 200, height: 50, backgroundColor: green ? \"green\" : \"red\", }} > My Button </button> ); }; Ressalvas: N\u00e3o \u00e9 poss\u00edvel utilizar pseudo-selectors, pseudo-elements, media queries, keyframe animations, entre outros. Dificulta a reutiliza\u00e7\u00e3o de c\u00f3digo (Escalabilidade). Dificulta a utiliza\u00e7\u00e3o de estilos baseados em props. Impossibilita de se usar Media queries N\u00e3o \u00e9 perform\u00e1tico, uma vez que o tamanho da DOM cresce proporcional a quantidade de elementos, mesmo que eles sejam repedidos. Com uso de SSR, a cada vez que a p\u00e1gina \u00e9 renderizada os estilos inline s\u00e3o baixados, uma vez que n\u00e3o h\u00e1 cache para o HTML gerado. Estilos inline s\u00e3o mais demorados para serem convertidos da VDOM para a DOM e levam mais tempo para o Browser conseguir tabalhar com eles tamb\u00e9m. Folhas de estilo Essa \u00e9 a forma mais tradicional de usar CSS. Podemos escrever nossa folha de estilo e importar para nosso componente. N\u00e3o precisa de nenhuma configura\u00e7\u00e3o adicional. /* style.css */ .container { width: 100px; height: 100px; background-color: red; } .container:hover { background-color: green; } import \"./style.css\"; function ColorBlock() { return <div className=\"container\">...</div>; } Ressalvas: Namespaces s\u00e3o globais e pode haver choque de nomes. Precisa usar uma estrat\u00e9gia de naming tipo BEM (Block Element Modifier). Algumas features avan\u00e7adas do CSS n\u00e3o estar\u00e3o dispon\u00edveis. Utiliza\u00e7\u00e3o de estilos din\u00e2micos baseado em Props envolve a cria\u00e7\u00e3o de mais classes CSS e complexidade maior para fazer o gerenciamento. Dificil de refatorar e elimiar c\u00f3digo. Dentre outros problemas descritos neste slide de Christopher Chedeau , um dos engenheiros do Facebook. Pr\u00e9-processadores Pr\u00e9-processadores CSS (SASS/LESS) s\u00e3o programas que recebem textos ou c\u00f3digos no nosso caso e efetuam convers\u00f5es lexicas, ou seja, entra com um c\u00f3digo e troca por outro, podendo incluir troca de palavras, inclus\u00e3o de c\u00f3digo condicional e at\u00e9 mesmo inclus\u00e3o de outros arquivos. No caso do SASS, podemos criar vari\u00e1veis, condicionais, repeti\u00e7\u00e3o, imports e at\u00e9 mesmo fun\u00e7\u00f5es e extender outros estilos para evitar duplica\u00e7\u00e3o de c\u00f3digo. \u00c9 poss\u00edvel fazer Nesting (aninhamento) de estilos. // variables $red = #f00; $green = #00aa00 // styles.scss @import \"variables\"; .container { width: 100px; height: 100px; background-color: $red; &:hover { background-color: $green; } &.button { ... } } import \"./style.scss\"; function ColorBlock() { return ( <div className=\"container\"> ... <button>...</button> </div> ); } Utilizando dessa forma ainda teremos problemas com colis\u00e3o de nomes, mas podemos trabalhar com m\u00f3dulos CSS no SASS e para isso devemos usar a extens\u00e3o .module.scss . // styles.module.scss @import \"variables\"; .container { width: 100px; height: 100px; background-color: $red; &:hover { background-color: $green; } &.button { ... } } import styles from \"./style.module.scss\"; function ColorBlock() { return ( <div className=\"container\"> ... <button>...</button> </div> ); } Ressalvas: Curva de aprendizagem. Pode ser dif\u00edcil de debugar. CSS Modules CSS Modules \u00e9 a evolu\u00e7\u00e3o das folhas de estilo. Possui escopo local, ou seja, n\u00e3o teremos problemas com colis\u00e3o de nomes. Tamb\u00e9m podemos trabalhar com vari\u00e1veis. O nome do arquivo precisa conter a extens\u00e3o .module.css para que o bundler reconhe\u00e7a como um m\u00f3dulo. A escrita do CSS continua a mesma. /* style.module.css */ --red: #e83f5b; --green: #4cd62b; .container { width: 100px; height: 100; background-color: var(--red); } .container:hover { background-color: var(--green); } .container button { ...; } import styles from \"./style.module.css\"; function ColorBlock() { return ( <div className=\"container\"> ... <button>...</button> </div> ); } Ressalvas: Ainda \u00e9 complicado utilizar estilos din\u00e2micos baseado em Props. Ainda n\u00e3o \u00e9 poss\u00edvel fazer Nesting de estilos. CSS-in-JS CSS-in-JS \u00e9 uma solu\u00e7\u00e3o como o pr\u00f3prio nome j\u00e1 diz: Escrever CSS com JS. Com essa solu\u00e7\u00e3o podemos aproveitar todos os m\u00e9todos atuais de componentiza\u00e7\u00e3o em JavaScript para criar componentes perform\u00e1ticos. Styled-Components Styled-Components \u00e9 uma das bibliotecas mais populares para React no assunto de CSS-in-JS. A ideia \u00e9 criar componentes como j\u00e1 utilizamos no React, por\u00e9m s\u00e3o componentes estilizados (ou de estilo). Segundo a documenta\u00e7\u00e3o oficial Styled-Components vem com as seguintes vantagens: Critical CSS Autom\u00e1tico: styled-components injeta somente os estilos e nada mais nos componentes autom\u00e1ticamente. Combinado com code splitting significa que somente vai carregar o que for necess\u00e1rio para montar o componente. Sem colis\u00e3o de classes: styled-components gera nomes de classes \u00fanicas para os estilos. Nunca vamos precisar preocupar com duplica\u00e7\u00e3o, sobreposi\u00e7\u00e3o ou erros de digita\u00e7\u00e3o. Remo\u00e7\u00e3o de CSS: Como criamos estilos para componentes e n\u00e3o baseado em classes, fica f\u00e1cil saber o que deletar. E quando deletamos um componente deletamos todos seu estilo. Estilo din\u00e2mico simples: Podemos criar estilos din\u00e2micos baseados nas props ou em temas de forma f\u00e1cil, sem usar um monte de classes. Manuten\u00e7\u00e3o sem dor: Como os estilos tem escopo do componente, n\u00e3o vamos mais precisar ficar \"ca\u00e7ando\" em v\u00e1rios arquivos qual estaria afetando o estilo. Vendor prefixing autom\u00e1tico: Voc\u00ea escreve seu CSS no melhor padr\u00e3o do mercado e pronto, os componentes cuidam para fornecer suporte para browsers antigos. Vejamos um exemplo: // style.js import styled from \"styled-components\"; export const Container = styled.div` width: 100px; height: 100px; background-color: red; &:hover { background-color: green; } &.button { ... } `; import { Container } from \"./style\"; function ColorBlock() { return ( <Container> ... <button>...</button> </Container> ); } E com estilos din\u00e2micos: // Button.styles.js import styled from \"styled-component\"; export const StyledButton = styled.button` width: 200px, height: 50px, backgroundColor: ${(props) => (props.bgColor ? props.bgColor : \"red\")}, `; import { StyledButton } from \"./Button.styles.js\"; const Button = ({ bgColor }) => { return <StyledButton bgColor={bgColor}>My Button</StyledButton>; }; Essa biblioteca ainda nos permite usar alguns recursos para melhor aproveitamento dos componentes gerados. Vamos supor que estamos construindo um Design System ou queremos reduzir a duplica\u00e7\u00e3o de c\u00f3digo para os estilos. Dado que temos dois componentes, um de texto que vamos chamar de Text e um de container que vamos chamar de Box, segue: // Text.js import styled from \"styled-components\"; const Text = styled.p` font-size: 1rem; color: black; `; export default Text; // Container.styles.js import styled from \"styled-components\"; const Container = styled.div` width: ${({ width }) => width}; height: ${({ height }) => height}; background-color: ${({ bgColor }) => bgColor}; border: ${({ border }) => border}; `; // Box.js import { Container } from \"./Container.styles\"; export default function Box({ width, height, bgColor, border, children }) { return ( <Container width={width} height={height} bgColor={bgColor} border={border}> {children} </Container> ); } E agora precisamos ter uma p\u00e1gina onde vamos ter um h1 e um form. Styled-Component nos d\u00e1 uma propriedade polif\u00f3rmica chamada as onde podemos mudar o tipo do elemento HTML e trocar o Text que \u00e9 uma tag p para h1 e o Box de div para form : // Form.js import Box from \"./Box\"; import Text from \"./Text\"; export default function Form() { return ( <Box as=\"from\" width=\"100%\" height=\"100%\" bgColor=\"transparent\" border=\"0\"> <Text as=\"h1\">Teremos uma tag form com um h1 dentro.</Text> </Box> ); } Ainda podemos extender o estilo de algum componente j\u00e1 criado e criar um novo: import styled from \"styled-components\"; import Box from \"./Box\"; export const StyledBox = styled(Box)` transition: border-color 300ms; &:hover { border: 1px dashed #999; } `; Dessa forma extendemos o componente Box e adicionamos a ele novas propriedades. \u00c9 importante ressaltar que para esse tipo de utiliza\u00e7\u00e3o em componentes React que retornam um componente Styled-Components, como \u00e9 o caso do Box, \u00e9 necess\u00e1rio adicionar uma propriedade chamada className no componente Box para que os estilos sejam corretamente aplicados: // Box.js import { Container } from \"./Container.styles\"; export default function Box({ width, height, bgColor, border, children, className, }) { return ( <Container className={className} width={width} height={height} bgColor={bgColor} border={border} > {children} </Container> ); } A documenta\u00e7\u00e3o da biblioteca \u00e9 extensa e bem completa. \u00c9 um excelente ponto de partida.","title":"07. ESTILOS"},{"location":"07.%20Estilos/#estilos","text":"Atualmente a biblioteca React n\u00e3o tem nenhuma opini\u00e3o sobre como estilos s\u00e3o definidos. Voc\u00ea pode criar estilos da maneira que achar melhor. React aceita tanto inline styles, quanto adicionando classes e os famosos CSS-in-JS.","title":"Estilos"},{"location":"07.%20Estilos/#inline-styles","text":"Para se usar CSS inline com React (JSX), deve se usar um objeto ao inv\u00e9s de string como no HTML puro. Os atributos precisam estar no padr\u00e3o camelCase e separados por virgula. Exatamente como num objeto JS comum. function ColorBlock() { const style = { margin: \"20px\", width: \"250px\", height: \"250px\", backgroundColor: \"yellow\", }; return <div style={styles}>...</div>; } function ColorBlock() { return ( <div style={{ backgroundColor: \"red\", width: \"100px\", height: \"100px\" }}> ... </div> ); } const Button = ({ green }) => { return ( <button style={{ width: 200, height: 50, backgroundColor: green ? \"green\" : \"red\", }} > My Button </button> ); }; Ressalvas: N\u00e3o \u00e9 poss\u00edvel utilizar pseudo-selectors, pseudo-elements, media queries, keyframe animations, entre outros. Dificulta a reutiliza\u00e7\u00e3o de c\u00f3digo (Escalabilidade). Dificulta a utiliza\u00e7\u00e3o de estilos baseados em props. Impossibilita de se usar Media queries N\u00e3o \u00e9 perform\u00e1tico, uma vez que o tamanho da DOM cresce proporcional a quantidade de elementos, mesmo que eles sejam repedidos. Com uso de SSR, a cada vez que a p\u00e1gina \u00e9 renderizada os estilos inline s\u00e3o baixados, uma vez que n\u00e3o h\u00e1 cache para o HTML gerado. Estilos inline s\u00e3o mais demorados para serem convertidos da VDOM para a DOM e levam mais tempo para o Browser conseguir tabalhar com eles tamb\u00e9m.","title":"Inline Styles"},{"location":"07.%20Estilos/#folhas-de-estilo","text":"Essa \u00e9 a forma mais tradicional de usar CSS. Podemos escrever nossa folha de estilo e importar para nosso componente. N\u00e3o precisa de nenhuma configura\u00e7\u00e3o adicional. /* style.css */ .container { width: 100px; height: 100px; background-color: red; } .container:hover { background-color: green; } import \"./style.css\"; function ColorBlock() { return <div className=\"container\">...</div>; } Ressalvas: Namespaces s\u00e3o globais e pode haver choque de nomes. Precisa usar uma estrat\u00e9gia de naming tipo BEM (Block Element Modifier). Algumas features avan\u00e7adas do CSS n\u00e3o estar\u00e3o dispon\u00edveis. Utiliza\u00e7\u00e3o de estilos din\u00e2micos baseado em Props envolve a cria\u00e7\u00e3o de mais classes CSS e complexidade maior para fazer o gerenciamento. Dificil de refatorar e elimiar c\u00f3digo. Dentre outros problemas descritos neste slide de Christopher Chedeau , um dos engenheiros do Facebook.","title":"Folhas de estilo"},{"location":"07.%20Estilos/#pre-processadores","text":"Pr\u00e9-processadores CSS (SASS/LESS) s\u00e3o programas que recebem textos ou c\u00f3digos no nosso caso e efetuam convers\u00f5es lexicas, ou seja, entra com um c\u00f3digo e troca por outro, podendo incluir troca de palavras, inclus\u00e3o de c\u00f3digo condicional e at\u00e9 mesmo inclus\u00e3o de outros arquivos. No caso do SASS, podemos criar vari\u00e1veis, condicionais, repeti\u00e7\u00e3o, imports e at\u00e9 mesmo fun\u00e7\u00f5es e extender outros estilos para evitar duplica\u00e7\u00e3o de c\u00f3digo. \u00c9 poss\u00edvel fazer Nesting (aninhamento) de estilos. // variables $red = #f00; $green = #00aa00 // styles.scss @import \"variables\"; .container { width: 100px; height: 100px; background-color: $red; &:hover { background-color: $green; } &.button { ... } } import \"./style.scss\"; function ColorBlock() { return ( <div className=\"container\"> ... <button>...</button> </div> ); } Utilizando dessa forma ainda teremos problemas com colis\u00e3o de nomes, mas podemos trabalhar com m\u00f3dulos CSS no SASS e para isso devemos usar a extens\u00e3o .module.scss . // styles.module.scss @import \"variables\"; .container { width: 100px; height: 100px; background-color: $red; &:hover { background-color: $green; } &.button { ... } } import styles from \"./style.module.scss\"; function ColorBlock() { return ( <div className=\"container\"> ... <button>...</button> </div> ); } Ressalvas: Curva de aprendizagem. Pode ser dif\u00edcil de debugar.","title":"Pr\u00e9-processadores"},{"location":"07.%20Estilos/#css-modules","text":"CSS Modules \u00e9 a evolu\u00e7\u00e3o das folhas de estilo. Possui escopo local, ou seja, n\u00e3o teremos problemas com colis\u00e3o de nomes. Tamb\u00e9m podemos trabalhar com vari\u00e1veis. O nome do arquivo precisa conter a extens\u00e3o .module.css para que o bundler reconhe\u00e7a como um m\u00f3dulo. A escrita do CSS continua a mesma. /* style.module.css */ --red: #e83f5b; --green: #4cd62b; .container { width: 100px; height: 100; background-color: var(--red); } .container:hover { background-color: var(--green); } .container button { ...; } import styles from \"./style.module.css\"; function ColorBlock() { return ( <div className=\"container\"> ... <button>...</button> </div> ); } Ressalvas: Ainda \u00e9 complicado utilizar estilos din\u00e2micos baseado em Props. Ainda n\u00e3o \u00e9 poss\u00edvel fazer Nesting de estilos.","title":"CSS Modules"},{"location":"07.%20Estilos/#css-in-js","text":"CSS-in-JS \u00e9 uma solu\u00e7\u00e3o como o pr\u00f3prio nome j\u00e1 diz: Escrever CSS com JS. Com essa solu\u00e7\u00e3o podemos aproveitar todos os m\u00e9todos atuais de componentiza\u00e7\u00e3o em JavaScript para criar componentes perform\u00e1ticos.","title":"CSS-in-JS"},{"location":"07.%20Estilos/#styled-components","text":"Styled-Components \u00e9 uma das bibliotecas mais populares para React no assunto de CSS-in-JS. A ideia \u00e9 criar componentes como j\u00e1 utilizamos no React, por\u00e9m s\u00e3o componentes estilizados (ou de estilo). Segundo a documenta\u00e7\u00e3o oficial Styled-Components vem com as seguintes vantagens: Critical CSS Autom\u00e1tico: styled-components injeta somente os estilos e nada mais nos componentes autom\u00e1ticamente. Combinado com code splitting significa que somente vai carregar o que for necess\u00e1rio para montar o componente. Sem colis\u00e3o de classes: styled-components gera nomes de classes \u00fanicas para os estilos. Nunca vamos precisar preocupar com duplica\u00e7\u00e3o, sobreposi\u00e7\u00e3o ou erros de digita\u00e7\u00e3o. Remo\u00e7\u00e3o de CSS: Como criamos estilos para componentes e n\u00e3o baseado em classes, fica f\u00e1cil saber o que deletar. E quando deletamos um componente deletamos todos seu estilo. Estilo din\u00e2mico simples: Podemos criar estilos din\u00e2micos baseados nas props ou em temas de forma f\u00e1cil, sem usar um monte de classes. Manuten\u00e7\u00e3o sem dor: Como os estilos tem escopo do componente, n\u00e3o vamos mais precisar ficar \"ca\u00e7ando\" em v\u00e1rios arquivos qual estaria afetando o estilo. Vendor prefixing autom\u00e1tico: Voc\u00ea escreve seu CSS no melhor padr\u00e3o do mercado e pronto, os componentes cuidam para fornecer suporte para browsers antigos. Vejamos um exemplo: // style.js import styled from \"styled-components\"; export const Container = styled.div` width: 100px; height: 100px; background-color: red; &:hover { background-color: green; } &.button { ... } `; import { Container } from \"./style\"; function ColorBlock() { return ( <Container> ... <button>...</button> </Container> ); } E com estilos din\u00e2micos: // Button.styles.js import styled from \"styled-component\"; export const StyledButton = styled.button` width: 200px, height: 50px, backgroundColor: ${(props) => (props.bgColor ? props.bgColor : \"red\")}, `; import { StyledButton } from \"./Button.styles.js\"; const Button = ({ bgColor }) => { return <StyledButton bgColor={bgColor}>My Button</StyledButton>; }; Essa biblioteca ainda nos permite usar alguns recursos para melhor aproveitamento dos componentes gerados. Vamos supor que estamos construindo um Design System ou queremos reduzir a duplica\u00e7\u00e3o de c\u00f3digo para os estilos. Dado que temos dois componentes, um de texto que vamos chamar de Text e um de container que vamos chamar de Box, segue: // Text.js import styled from \"styled-components\"; const Text = styled.p` font-size: 1rem; color: black; `; export default Text; // Container.styles.js import styled from \"styled-components\"; const Container = styled.div` width: ${({ width }) => width}; height: ${({ height }) => height}; background-color: ${({ bgColor }) => bgColor}; border: ${({ border }) => border}; `; // Box.js import { Container } from \"./Container.styles\"; export default function Box({ width, height, bgColor, border, children }) { return ( <Container width={width} height={height} bgColor={bgColor} border={border}> {children} </Container> ); } E agora precisamos ter uma p\u00e1gina onde vamos ter um h1 e um form. Styled-Component nos d\u00e1 uma propriedade polif\u00f3rmica chamada as onde podemos mudar o tipo do elemento HTML e trocar o Text que \u00e9 uma tag p para h1 e o Box de div para form : // Form.js import Box from \"./Box\"; import Text from \"./Text\"; export default function Form() { return ( <Box as=\"from\" width=\"100%\" height=\"100%\" bgColor=\"transparent\" border=\"0\"> <Text as=\"h1\">Teremos uma tag form com um h1 dentro.</Text> </Box> ); } Ainda podemos extender o estilo de algum componente j\u00e1 criado e criar um novo: import styled from \"styled-components\"; import Box from \"./Box\"; export const StyledBox = styled(Box)` transition: border-color 300ms; &:hover { border: 1px dashed #999; } `; Dessa forma extendemos o componente Box e adicionamos a ele novas propriedades. \u00c9 importante ressaltar que para esse tipo de utiliza\u00e7\u00e3o em componentes React que retornam um componente Styled-Components, como \u00e9 o caso do Box, \u00e9 necess\u00e1rio adicionar uma propriedade chamada className no componente Box para que os estilos sejam corretamente aplicados: // Box.js import { Container } from \"./Container.styles\"; export default function Box({ width, height, bgColor, border, children, className, }) { return ( <Container className={className} width={width} height={height} bgColor={bgColor} border={border} > {children} </Container> ); } A documenta\u00e7\u00e3o da biblioteca \u00e9 extensa e bem completa. \u00c9 um excelente ponto de partida.","title":"Styled-Components"},{"location":"09.%20Atomic%20Design/","text":"Atomic Design O Atomic Design \u00e9 uma metodologia para criar design systems desenvolvida pelo Brad Frost , \u00e9 uma analogia cient\u00edfica que nos ajuda a pensar as interfaces de uma maneira mais completa. Motiva\u00e7\u00e3o A motiva\u00e7\u00e3o surgiu analisando algumas caracter\u00edsticas do projeto em conjunto com as defini\u00e7\u00f5es da equipe de UX. Projetos grandes que requerem manuten\u00e7\u00e3o ao longo do tempo, exigem que nossas interfaces tenham uma alta capacidade de replica\u00e7\u00e3o e expans\u00e3o de forma simples e sem perder a ess\u00eancia da experi\u00eancia atual. \u00c9 neste ponto que entra o Atomic Web Design, onde come\u00e7amos a entender nossas interfaces como quebra-cabe\u00e7as, facilitando nosso trabalho para estruturar nossos componentes e construir a interface do sistema modular. Benef\u00edcios Consist\u00eancia e coes\u00e3o. Fluxo de trabalho para a equipe - economizando tempo e dinheiro. Fluxo de trabalho mais colaborativo entre todas as \u00e1rea envolvidas no projeto. Vocabul\u00e1rio compartilhado entre todos em uma empresa, incluindo fornecedores terceiros. Documenta\u00e7\u00e3o que ajuda as partes interessadas: colegas e terceiros a aprenderem sobre a biblioteca e reposit\u00f3rio. Facilita modifica\u00e7\u00e3o, amplia\u00e7\u00e3o e melhoria. Estrutura \u00c1tomos Os \u00c1tomos s\u00e3o os blocos b\u00e1sicos da interface. Os \u00e1tomos s\u00e3o nossas tags HTML, como um <label> de formul\u00e1rio, um <input> ou um <button> . S\u00e3o basicamente os componentes mais simples e reutiliz\u00e1veis da aplica\u00e7\u00e3o. Os \u00e1tomos tamb\u00e9m podem incluir elementos mais abstratos, como paletas de cores e fontes. Cada \u00e1tomo de interface possui suas pr\u00f3prias propriedades exclusivas, como as dimens\u00f5es de uma imagem ou o tamanho da fonte principal de um cabe\u00e7alho. Essas propriedades influenciam como cada \u00e1tomo deve ser aplicado na interface. Mol\u00e9culas Moleculas s\u00e3o basicamente agrupamentos de um ou mais \u00e1tomos que funcionam juntos como uma unidade. Por exemplo um campo de busca que combina as mol\u00e9cuas de <label> , <input> e <button> . Organismos Organismos s\u00e3o componentes de interface relativamente complexos compostos por grupos de mol\u00e9culas e/ou \u00e1tomos e/ou outros organismos. Esses organismos formam se\u00e7\u00f5es distintas de uma interface, como header , footer ou um sidebar , por exemplo. Templates Os Templates consistem principalmente de grupos de organismos estruturados juntos para formar p\u00e1ginas. \u00c9 aqui que come\u00e7amos a ver coisas como layout em a\u00e7\u00e3o. Semelhante a um Wireframe, \u00e9 aqui por exemplo, onde aplicamos os skeletons/Shimmer (placeholders de conte\u00fado). P\u00e1ginas P\u00e1ginas s\u00e3o inst\u00e2ncias espec\u00edficas de templates. Aqui, o espa\u00e7o reservado para o conteudo \u00e9 substitu\u00eddo pelo conte\u00fado (representativo) real para fornecer uma representa\u00e7\u00e3o precisa do que o usu\u00e1rio ver\u00e1.","title":"09. ATOMIC DESIGN"},{"location":"09.%20Atomic%20Design/#atomic-design","text":"O Atomic Design \u00e9 uma metodologia para criar design systems desenvolvida pelo Brad Frost , \u00e9 uma analogia cient\u00edfica que nos ajuda a pensar as interfaces de uma maneira mais completa.","title":"Atomic Design"},{"location":"09.%20Atomic%20Design/#motivacao","text":"A motiva\u00e7\u00e3o surgiu analisando algumas caracter\u00edsticas do projeto em conjunto com as defini\u00e7\u00f5es da equipe de UX. Projetos grandes que requerem manuten\u00e7\u00e3o ao longo do tempo, exigem que nossas interfaces tenham uma alta capacidade de replica\u00e7\u00e3o e expans\u00e3o de forma simples e sem perder a ess\u00eancia da experi\u00eancia atual. \u00c9 neste ponto que entra o Atomic Web Design, onde come\u00e7amos a entender nossas interfaces como quebra-cabe\u00e7as, facilitando nosso trabalho para estruturar nossos componentes e construir a interface do sistema modular.","title":"Motiva\u00e7\u00e3o"},{"location":"09.%20Atomic%20Design/#beneficios","text":"Consist\u00eancia e coes\u00e3o. Fluxo de trabalho para a equipe - economizando tempo e dinheiro. Fluxo de trabalho mais colaborativo entre todas as \u00e1rea envolvidas no projeto. Vocabul\u00e1rio compartilhado entre todos em uma empresa, incluindo fornecedores terceiros. Documenta\u00e7\u00e3o que ajuda as partes interessadas: colegas e terceiros a aprenderem sobre a biblioteca e reposit\u00f3rio. Facilita modifica\u00e7\u00e3o, amplia\u00e7\u00e3o e melhoria.","title":"Benef\u00edcios"},{"location":"09.%20Atomic%20Design/#estrutura","text":"","title":"Estrutura"},{"location":"09.%20Atomic%20Design/#atomos","text":"Os \u00c1tomos s\u00e3o os blocos b\u00e1sicos da interface. Os \u00e1tomos s\u00e3o nossas tags HTML, como um <label> de formul\u00e1rio, um <input> ou um <button> . S\u00e3o basicamente os componentes mais simples e reutiliz\u00e1veis da aplica\u00e7\u00e3o. Os \u00e1tomos tamb\u00e9m podem incluir elementos mais abstratos, como paletas de cores e fontes. Cada \u00e1tomo de interface possui suas pr\u00f3prias propriedades exclusivas, como as dimens\u00f5es de uma imagem ou o tamanho da fonte principal de um cabe\u00e7alho. Essas propriedades influenciam como cada \u00e1tomo deve ser aplicado na interface.","title":"\u00c1tomos"},{"location":"09.%20Atomic%20Design/#moleculas","text":"Moleculas s\u00e3o basicamente agrupamentos de um ou mais \u00e1tomos que funcionam juntos como uma unidade. Por exemplo um campo de busca que combina as mol\u00e9cuas de <label> , <input> e <button> .","title":"Mol\u00e9culas"},{"location":"09.%20Atomic%20Design/#organismos","text":"Organismos s\u00e3o componentes de interface relativamente complexos compostos por grupos de mol\u00e9culas e/ou \u00e1tomos e/ou outros organismos. Esses organismos formam se\u00e7\u00f5es distintas de uma interface, como header , footer ou um sidebar , por exemplo.","title":"Organismos"},{"location":"09.%20Atomic%20Design/#templates","text":"Os Templates consistem principalmente de grupos de organismos estruturados juntos para formar p\u00e1ginas. \u00c9 aqui que come\u00e7amos a ver coisas como layout em a\u00e7\u00e3o. Semelhante a um Wireframe, \u00e9 aqui por exemplo, onde aplicamos os skeletons/Shimmer (placeholders de conte\u00fado).","title":"Templates"},{"location":"09.%20Atomic%20Design/#paginas","text":"P\u00e1ginas s\u00e3o inst\u00e2ncias espec\u00edficas de templates. Aqui, o espa\u00e7o reservado para o conteudo \u00e9 substitu\u00eddo pelo conte\u00fado (representativo) real para fornecer uma representa\u00e7\u00e3o precisa do que o usu\u00e1rio ver\u00e1.","title":"P\u00e1ginas"},{"location":"10.%20Testes%20unitarios/","text":"Testes unit\u00e1rios DISCLAIMER: Vamos assumir que a linguagem de programa\u00e7\u00e3o \u00e9 JavaScript . O Framework de teste padr\u00e3o ser\u00e1 o Jest e todos os exemplos ser\u00e3o baseados nele, mas vamos falar sobre outros frameworks de teste conhecidos para o JavaScript. O mindset utilizado ser\u00e1 para aplica\u00e7\u00f5es Frontend . O que \u00e9 um teste unit\u00e1rio ou de unidade? Por teste unit\u00e1rio ou teste de unidade \u00e9 entendido que testamos a menor parte test\u00e1vel de um software, o que podemos assumir como uma fun\u00e7\u00e3o ou m\u00e9todo de uma classe. Por exemplo, dado a fun\u00e7\u00e3o: function sum(value1, value2) { return value1 + value2; } Um teste simples para essa fun\u00e7\u00e3o seria: expect(sum(1, 2)).toEqual(3); O exemplo acima \u00e9 um cl\u00e1ssico que voc\u00ea vai poder encontrar por toda internet. Mas para que serve teste unit\u00e1rio? Que dor que o teste resolve? O que devemos testar? Como testar? Fun\u00e7\u00e3o dos testes unit\u00e1rios Os testes unit\u00e1rios nos d\u00e3o uma vantagem muito maior do que deixar os pequenos peda\u00e7os testados e ver o coverage subindo, eles nos d\u00e3o confian\u00e7a . Confian\u00e7a que nossa aplica\u00e7\u00e3o vai funcionar quando seus usu\u00e1rios a utilizarem. Outra vantagem dos testes unit\u00e1rios \u00e9 quando precisamos refatorar. J\u00e1 pensou se precisar refatorar a fun\u00e7\u00e3o sum para que, internamente, ela fique mais explicita? function sum(value1, value2) { const result = value1 + value2; return result; } Ou se a gente mudasse de named function para arrow function ? const sum = (x, y) => x + y; Refatoramos os detalhes da implementa\u00e7\u00e3o de nossa fun\u00e7\u00e3o, mesmo assim o teste continuaria passando. Este \u00e9 o poder dos testes: Nos dar confian\u00e7a tanto para mudan\u00e7as tanto para garantir o funcionamento do c\u00f3digo em produ\u00e7\u00e3o. Frameworks de teste Existem v\u00e1rios framworks de teste para JavaScript, como Cypress, Jasmine, Mocha e Jest. Quando usamos o Create React App para criar nossa aplica\u00e7\u00e3o React, o Jest faz parte do pacote que \u00e9 instalado pelo CRA. Jest foi criado pelo Facebook, \u00e9 um framework que n\u00e3o precisa de muita configura\u00e7\u00e3o, uma vez que ele j\u00e1 vem com suporte a mock e sua biblioteca de assers\u00f5es. Fora isso, \u00e9 bem documentado e considerado como uma r\u00e1pido e perform\u00e1tico. Jasmine e Mocha foram (e s\u00e3o) frameworks de teste muito famosos at\u00e9 2016 segundo o site State of JS 2020 survey , por\u00e9m perderam espa\u00e7o para o Jest pela facilidade de instala\u00e7\u00e3o e configura\u00e7\u00e3o. J\u00e1 o Cypress \u00e9 um framwork voltado mais para testes de ponta a ponta, os famosos E2E (end to end) e muito utilizado para valida\u00e7\u00e3o da UI e fluxos completos. Tamb\u00e9m \u00e9 poss\u00edvel realizar testes de integra\u00e7\u00e3o e at\u00e9 unit\u00e1rios. Bibliotecas de teste Dentre as v\u00e1rias bibliotecas de teste, vamos destacar as duas mais utilizadas hoje no Frontend, principalmente com React: Enzyme e React Testing Library . Tanto Enzyme quanto RTL s\u00e3o \"utilit\u00e1rios\" que usamos junto ao nosso framework de teste, deixando mais f\u00e1cil criar testes para nossos componentes construidos com o React. Geralmente essas bibliotecas adicionam formas de manipular e/ou simular eventos como clique e algumas formas de realizar a assers\u00e3o dos nossos testes. Nosso foco aqui ser\u00e1 com a biblioteca React Testing Library. N\u00e3o entraremos nos detalhes de configura\u00e7\u00e3o inicial de cada biblioteca. Enzyme Criada pela equipe da AirBnB que j\u00e1 construiu v\u00e1rios outros componentes para React e tamb\u00e9m uma Style Guide muito famosa utilizada por muitos Devs quando falamos de desenvolvimento JavaScript / TypeScript. Na documenta\u00e7\u00e3o oficial do Enzyme , diz que o Enzyme \u00e9 um utilit\u00e1rio de testes para o React que torna f\u00e1cil testar a sa\u00edda de nossos componentes. A API do Enzyme \u00e9 jQuery-like, ou seja, imita a API do jQuery para localizar elementos, disparar eventos com m\u00e9todos como find() e ainda pondendo buscar elementos por id , name e className , por exemplo. No Enzyme possu\u00edmos basicamente tr\u00eas m\u00e9todos para renderizar um componente para o teste: mount() Renderiza toda a arvore DOM com todos os childrens e d\u00e1 a possibilidade de usar toda API do Enzyme simulando cliques, acessando elementos que foram renderizados na DOM e muito mais. shallow() Renderiza somente o componente sem seus filhos e s\u00f3 torna poss\u00edvel simular cliques e outros eventos apenas para o componente renderizado em quest\u00e3o, uma vez que os componentes filhos n\u00e3o s\u00e3o renderizados. Atualmente a API de Hooks do React n\u00e3o funciona muito bem com shallow rendering . render() Retorna uma string com o c\u00f3digo gerado em HTML. Abaixo, alguns exemplos de testes utilizando Enzyme: import MyComponent from \"./MyComponent\"; import Foo from \"./Foo\"; import { expect } from \"chai\"; import { shallow } from \"enzyme\"; import { mount } from \"enzyme\"; // Shallow it(\"renders three <Foo /> components\", () => { const wrapper = shallow(<MyComponent />); expect(wrapper.find(Foo)).to.have.lengthOf(3); }); // Mount it(\"allows us to set props\", () => { const wrapper = mount(<Foo bar=\"baz\" />); expect(wrapper.props().bar).to.equal(\"baz\"); wrapper.setProps({ bar: \"foo\" }); expect(wrapper.props().bar).to.equal(\"foo\"); }); // Render it(\"renders three `.foo-bar`s\", () => { const wrapper = render(<Foo />); expect(wrapper.find(\".foo-bar\")).to.have.lengthOf(3); }); React Testing Library The more your tests resemble the way your software is used, the more confidence they can give you. Kent C. Dodds Quanto mais seus testes se assemelham \u00e0 forma como o software \u00e9 usado, mais confian\u00e7a eles podem lhe dar. Google Translate Essa biblioteca para o React faz parte de um conjunto de bibliotecas chamado Testing Library que \u00e9 um utilit\u00e1rio para testes que encoraja boas pr\u00e1ticas de teste. Al\u00e9m de React, voc\u00ea pode encontrar para uma s\u00e9rie de outras bibliotecas e frameworks como Angular, Vue e Cypress. React Testing Library foi escrita por Kent C Dodds que tem apresentado uma outra forma de pensar em testes, principalmente para o Frontend. A principal ideia dessa biblioteca \u00e9 que n\u00e3o devemos nos atentar aos detalhes de implementa\u00e7\u00e3o durante o teste e simplesmente devemos simular o comportamento do usu\u00e1rio exatamente com o que ser\u00e1 visto em tela. Kent escreveu um belo artigo sobre o motivo que detalhes de implementa\u00e7\u00e3o nos testes s\u00e3o uma receita para o desastre . Como a biblioteca RTL funciona? O mindset dessa biblioteca \u00e9 de criar testes que se assemelham com o comportamento do usu\u00e1rio da aplia\u00e7\u00e3o. O que deve acontecer quando o usu\u00e1rio clicar no bot\u00e3o? O que ele vai ver? Quais elementos est\u00e3o presentes na tela? Quando executamos o teste com essa biblioteca o componente sempre ser\u00e1 montado com todos os seus filhos e ir\u00e1 se comportar exatamente como se estivesse sendo executado no browser. E este \u00e9 o motivo de n\u00e3o precisarmos preocupar com os detalhes de implementa\u00e7\u00e3o durante o teste. Mesmo que, internamente o componente seja alterado, o teste continuar\u00e1 passando. Um uso muito importante dessa biblioteca \u00e9 de trabalharmos com TDD, onde podemos escrever os testes com os resultados esperados e depois ir construindo o componente ir vendo os testes passarem, uma vez que n\u00e3o precisamos nos preocupar com os detalhes da implementa\u00e7\u00e3o da funcionalidade e isso \u00e9 muito lindo. A RTL tamb\u00e9m sugere fortemente que devemos sempre pensar em acessibilidade e a biblioteca nos fornece uma API para buscar elementos inclusive pela Role . Existe na documenta\u00e7\u00e3o da Testing Library uma sess\u00e3o dedicada para explicar os m\u00e9todos dispon\u00edveis pela ordem de prioridade para acessar algum componente ou fazer alguma asser\u00e7\u00e3o. Al\u00e9m dos testes unit\u00e1rios Segundo a documenta\u00e7\u00e3o oficial da biblioteca, podemos escrever al\u00e9m dos testes unit\u00e1rios, testes de integra\u00e7\u00e3o e at\u00e9 mesmo testes de ponta a ponta, os famosos E2E. Podemos integrar tamb\u00e9m a bibliteca de asser\u00e7\u00e3o com o Cypress e usar os mesmos m\u00e9todos que utilizamos nos testes unit\u00e1rios com os testes E2E e usando o mesmo mindset de sempre testar o que o usu\u00e1rio est\u00e1 vendo, ou o que realmente ele vai fazer e ver. Essa \u00e9 a famosa pir\u00e2mide de testes adaptada por Kent C. Dodds, evidenciando que, testes unit\u00e1rios s\u00e3o mais baratos e r\u00e1pidos, ent\u00e3o dever\u00edamos gastar mais tempo nos testes unit\u00e1rios, certo? Segundo Dodds, faltou dizer nessa pir\u00e2mide que, quanto mais subimos, aumentamos o coeficiente de confian\u00e7a para cada forma de teste Martin Fowler, termina o assunto sobre a pir\u00e2mide de testes afirmando o seguinte: Agora, segundo Kent, nossas ferramentas de teste s\u00e3o incriveis e essa afirma\u00e7\u00e3o de Fowler est\u00e1 \"menos verdadeira\" e ent\u00e3o ele mudou o conceito de pir\u00e2mide e criou o Trof\u00e9u dos testes: ( Confira neste Tweet de Kent ) De baixo para cima temos: Testes est\u00e1ticos (Static): Utilizamos com ferramentas como ESLint ou com TypeScript que consegue pegar erros de Typos e regras bem mais r\u00e1pido do que num Code Review. A analize \u00e9 realizada enquanto estamos digitando o c\u00f3digo. Testes unit\u00e1rios (Unit): Verifica se, individualmente e isoladas, as partes funcionam como esperado. Testes de integra\u00e7\u00e3o (Integration): Verifica se as partes funcionam em harmonia quando est\u00e3o juntas. Tamb\u00e9m chamado as vezes de teste de componente. Testes de ponta a ponta (End to End): Se comporta como um usu\u00e1rio usando a aplica\u00e7\u00e3o para verificar se tudo est\u00e1 funcionando corretamente. Tambem chamado as vezes de Teste funcional (Functional testing) ou e2e. Segundo o Trof\u00e9u dos testes, devemos ter mais testes de integra\u00e7\u00e3o do que unit\u00e1rios e isso se d\u00e1 muitas vezes porque n\u00e3o temos como ou n\u00e3o vale a pena testar de forma isolada um componente de UI, como um bot\u00e3o ou um input estilizado, por exemplo. Pense: N\u00e3o importa quantas propriedades o componente de bot\u00e3o ou input recebem. \u00c9 bom, se for poss\u00edvel, test\u00e1-los isoladamente, mas testar integrados com uma p\u00e1gina onde os bot\u00f5es e o input realmente ser\u00e3o utilizados vai nos dar muito mais confian\u00e7a nos testes e quem sabe at\u00e9 nem precisar\u00edamos nos preocupar com os testes unit\u00e1rios para esses componentes, hein? Talvez poder\u00edamos passar mais tempo escrevendo testes de integra\u00e7\u00e3o e criando menos mocks porque hoje eles seriam uma balan\u00e7a perfeita entre confian\u00e7a e velocidade/custo de desenvolvimento. Finalizando O assunto sobre testes \u00e9 de fato cheio de pol\u00eamicas. A linha que divide o que \u00e9 cada tipo de teste, saber o que testar, quando testar e qual ferramenta usar \u00e9 muito t\u00eanue e tudo isso gera muita d\u00favida e muita discuss\u00e3o. O fato \u00e9 que os testes devem nos dar confian\u00e7a para fazermos as altera\u00e7\u00f5es que precisarmos em nossa aplica\u00e7\u00e3o e garantindo que a aplica\u00e7\u00e3o continuar\u00e1 funcionando em produ\u00e7\u00e3o. N\u00e3o h\u00e1 d\u00favidas que essa \u00e9 a ess\u00eancia do teste de software.","title":"10. TESTES UNITARIOS"},{"location":"10.%20Testes%20unitarios/#testes-unitarios","text":"DISCLAIMER: Vamos assumir que a linguagem de programa\u00e7\u00e3o \u00e9 JavaScript . O Framework de teste padr\u00e3o ser\u00e1 o Jest e todos os exemplos ser\u00e3o baseados nele, mas vamos falar sobre outros frameworks de teste conhecidos para o JavaScript. O mindset utilizado ser\u00e1 para aplica\u00e7\u00f5es Frontend .","title":"Testes unit\u00e1rios"},{"location":"10.%20Testes%20unitarios/#o-que-e-um-teste-unitario-ou-de-unidade","text":"Por teste unit\u00e1rio ou teste de unidade \u00e9 entendido que testamos a menor parte test\u00e1vel de um software, o que podemos assumir como uma fun\u00e7\u00e3o ou m\u00e9todo de uma classe. Por exemplo, dado a fun\u00e7\u00e3o: function sum(value1, value2) { return value1 + value2; } Um teste simples para essa fun\u00e7\u00e3o seria: expect(sum(1, 2)).toEqual(3); O exemplo acima \u00e9 um cl\u00e1ssico que voc\u00ea vai poder encontrar por toda internet. Mas para que serve teste unit\u00e1rio? Que dor que o teste resolve? O que devemos testar? Como testar?","title":"O que \u00e9 um teste unit\u00e1rio ou de unidade?"},{"location":"10.%20Testes%20unitarios/#funcao-dos-testes-unitarios","text":"Os testes unit\u00e1rios nos d\u00e3o uma vantagem muito maior do que deixar os pequenos peda\u00e7os testados e ver o coverage subindo, eles nos d\u00e3o confian\u00e7a . Confian\u00e7a que nossa aplica\u00e7\u00e3o vai funcionar quando seus usu\u00e1rios a utilizarem. Outra vantagem dos testes unit\u00e1rios \u00e9 quando precisamos refatorar. J\u00e1 pensou se precisar refatorar a fun\u00e7\u00e3o sum para que, internamente, ela fique mais explicita? function sum(value1, value2) { const result = value1 + value2; return result; } Ou se a gente mudasse de named function para arrow function ? const sum = (x, y) => x + y; Refatoramos os detalhes da implementa\u00e7\u00e3o de nossa fun\u00e7\u00e3o, mesmo assim o teste continuaria passando. Este \u00e9 o poder dos testes: Nos dar confian\u00e7a tanto para mudan\u00e7as tanto para garantir o funcionamento do c\u00f3digo em produ\u00e7\u00e3o.","title":"Fun\u00e7\u00e3o dos testes unit\u00e1rios"},{"location":"10.%20Testes%20unitarios/#frameworks-de-teste","text":"Existem v\u00e1rios framworks de teste para JavaScript, como Cypress, Jasmine, Mocha e Jest. Quando usamos o Create React App para criar nossa aplica\u00e7\u00e3o React, o Jest faz parte do pacote que \u00e9 instalado pelo CRA. Jest foi criado pelo Facebook, \u00e9 um framework que n\u00e3o precisa de muita configura\u00e7\u00e3o, uma vez que ele j\u00e1 vem com suporte a mock e sua biblioteca de assers\u00f5es. Fora isso, \u00e9 bem documentado e considerado como uma r\u00e1pido e perform\u00e1tico. Jasmine e Mocha foram (e s\u00e3o) frameworks de teste muito famosos at\u00e9 2016 segundo o site State of JS 2020 survey , por\u00e9m perderam espa\u00e7o para o Jest pela facilidade de instala\u00e7\u00e3o e configura\u00e7\u00e3o. J\u00e1 o Cypress \u00e9 um framwork voltado mais para testes de ponta a ponta, os famosos E2E (end to end) e muito utilizado para valida\u00e7\u00e3o da UI e fluxos completos. Tamb\u00e9m \u00e9 poss\u00edvel realizar testes de integra\u00e7\u00e3o e at\u00e9 unit\u00e1rios.","title":"Frameworks de teste"},{"location":"10.%20Testes%20unitarios/#bibliotecas-de-teste","text":"Dentre as v\u00e1rias bibliotecas de teste, vamos destacar as duas mais utilizadas hoje no Frontend, principalmente com React: Enzyme e React Testing Library . Tanto Enzyme quanto RTL s\u00e3o \"utilit\u00e1rios\" que usamos junto ao nosso framework de teste, deixando mais f\u00e1cil criar testes para nossos componentes construidos com o React. Geralmente essas bibliotecas adicionam formas de manipular e/ou simular eventos como clique e algumas formas de realizar a assers\u00e3o dos nossos testes. Nosso foco aqui ser\u00e1 com a biblioteca React Testing Library. N\u00e3o entraremos nos detalhes de configura\u00e7\u00e3o inicial de cada biblioteca.","title":"Bibliotecas de teste"},{"location":"10.%20Testes%20unitarios/#enzyme","text":"Criada pela equipe da AirBnB que j\u00e1 construiu v\u00e1rios outros componentes para React e tamb\u00e9m uma Style Guide muito famosa utilizada por muitos Devs quando falamos de desenvolvimento JavaScript / TypeScript. Na documenta\u00e7\u00e3o oficial do Enzyme , diz que o Enzyme \u00e9 um utilit\u00e1rio de testes para o React que torna f\u00e1cil testar a sa\u00edda de nossos componentes. A API do Enzyme \u00e9 jQuery-like, ou seja, imita a API do jQuery para localizar elementos, disparar eventos com m\u00e9todos como find() e ainda pondendo buscar elementos por id , name e className , por exemplo. No Enzyme possu\u00edmos basicamente tr\u00eas m\u00e9todos para renderizar um componente para o teste: mount() Renderiza toda a arvore DOM com todos os childrens e d\u00e1 a possibilidade de usar toda API do Enzyme simulando cliques, acessando elementos que foram renderizados na DOM e muito mais. shallow() Renderiza somente o componente sem seus filhos e s\u00f3 torna poss\u00edvel simular cliques e outros eventos apenas para o componente renderizado em quest\u00e3o, uma vez que os componentes filhos n\u00e3o s\u00e3o renderizados. Atualmente a API de Hooks do React n\u00e3o funciona muito bem com shallow rendering . render() Retorna uma string com o c\u00f3digo gerado em HTML. Abaixo, alguns exemplos de testes utilizando Enzyme: import MyComponent from \"./MyComponent\"; import Foo from \"./Foo\"; import { expect } from \"chai\"; import { shallow } from \"enzyme\"; import { mount } from \"enzyme\"; // Shallow it(\"renders three <Foo /> components\", () => { const wrapper = shallow(<MyComponent />); expect(wrapper.find(Foo)).to.have.lengthOf(3); }); // Mount it(\"allows us to set props\", () => { const wrapper = mount(<Foo bar=\"baz\" />); expect(wrapper.props().bar).to.equal(\"baz\"); wrapper.setProps({ bar: \"foo\" }); expect(wrapper.props().bar).to.equal(\"foo\"); }); // Render it(\"renders three `.foo-bar`s\", () => { const wrapper = render(<Foo />); expect(wrapper.find(\".foo-bar\")).to.have.lengthOf(3); });","title":"Enzyme"},{"location":"10.%20Testes%20unitarios/#react-testing-library","text":"The more your tests resemble the way your software is used, the more confidence they can give you. Kent C. Dodds Quanto mais seus testes se assemelham \u00e0 forma como o software \u00e9 usado, mais confian\u00e7a eles podem lhe dar. Google Translate Essa biblioteca para o React faz parte de um conjunto de bibliotecas chamado Testing Library que \u00e9 um utilit\u00e1rio para testes que encoraja boas pr\u00e1ticas de teste. Al\u00e9m de React, voc\u00ea pode encontrar para uma s\u00e9rie de outras bibliotecas e frameworks como Angular, Vue e Cypress. React Testing Library foi escrita por Kent C Dodds que tem apresentado uma outra forma de pensar em testes, principalmente para o Frontend. A principal ideia dessa biblioteca \u00e9 que n\u00e3o devemos nos atentar aos detalhes de implementa\u00e7\u00e3o durante o teste e simplesmente devemos simular o comportamento do usu\u00e1rio exatamente com o que ser\u00e1 visto em tela. Kent escreveu um belo artigo sobre o motivo que detalhes de implementa\u00e7\u00e3o nos testes s\u00e3o uma receita para o desastre .","title":"React Testing Library"},{"location":"10.%20Testes%20unitarios/#como-a-biblioteca-rtl-funciona","text":"O mindset dessa biblioteca \u00e9 de criar testes que se assemelham com o comportamento do usu\u00e1rio da aplia\u00e7\u00e3o. O que deve acontecer quando o usu\u00e1rio clicar no bot\u00e3o? O que ele vai ver? Quais elementos est\u00e3o presentes na tela? Quando executamos o teste com essa biblioteca o componente sempre ser\u00e1 montado com todos os seus filhos e ir\u00e1 se comportar exatamente como se estivesse sendo executado no browser. E este \u00e9 o motivo de n\u00e3o precisarmos preocupar com os detalhes de implementa\u00e7\u00e3o durante o teste. Mesmo que, internamente o componente seja alterado, o teste continuar\u00e1 passando. Um uso muito importante dessa biblioteca \u00e9 de trabalharmos com TDD, onde podemos escrever os testes com os resultados esperados e depois ir construindo o componente ir vendo os testes passarem, uma vez que n\u00e3o precisamos nos preocupar com os detalhes da implementa\u00e7\u00e3o da funcionalidade e isso \u00e9 muito lindo. A RTL tamb\u00e9m sugere fortemente que devemos sempre pensar em acessibilidade e a biblioteca nos fornece uma API para buscar elementos inclusive pela Role . Existe na documenta\u00e7\u00e3o da Testing Library uma sess\u00e3o dedicada para explicar os m\u00e9todos dispon\u00edveis pela ordem de prioridade para acessar algum componente ou fazer alguma asser\u00e7\u00e3o.","title":"Como a biblioteca RTL funciona?"},{"location":"10.%20Testes%20unitarios/#alem-dos-testes-unitarios","text":"Segundo a documenta\u00e7\u00e3o oficial da biblioteca, podemos escrever al\u00e9m dos testes unit\u00e1rios, testes de integra\u00e7\u00e3o e at\u00e9 mesmo testes de ponta a ponta, os famosos E2E. Podemos integrar tamb\u00e9m a bibliteca de asser\u00e7\u00e3o com o Cypress e usar os mesmos m\u00e9todos que utilizamos nos testes unit\u00e1rios com os testes E2E e usando o mesmo mindset de sempre testar o que o usu\u00e1rio est\u00e1 vendo, ou o que realmente ele vai fazer e ver. Essa \u00e9 a famosa pir\u00e2mide de testes adaptada por Kent C. Dodds, evidenciando que, testes unit\u00e1rios s\u00e3o mais baratos e r\u00e1pidos, ent\u00e3o dever\u00edamos gastar mais tempo nos testes unit\u00e1rios, certo? Segundo Dodds, faltou dizer nessa pir\u00e2mide que, quanto mais subimos, aumentamos o coeficiente de confian\u00e7a para cada forma de teste Martin Fowler, termina o assunto sobre a pir\u00e2mide de testes afirmando o seguinte: Agora, segundo Kent, nossas ferramentas de teste s\u00e3o incriveis e essa afirma\u00e7\u00e3o de Fowler est\u00e1 \"menos verdadeira\" e ent\u00e3o ele mudou o conceito de pir\u00e2mide e criou o Trof\u00e9u dos testes: ( Confira neste Tweet de Kent ) De baixo para cima temos: Testes est\u00e1ticos (Static): Utilizamos com ferramentas como ESLint ou com TypeScript que consegue pegar erros de Typos e regras bem mais r\u00e1pido do que num Code Review. A analize \u00e9 realizada enquanto estamos digitando o c\u00f3digo. Testes unit\u00e1rios (Unit): Verifica se, individualmente e isoladas, as partes funcionam como esperado. Testes de integra\u00e7\u00e3o (Integration): Verifica se as partes funcionam em harmonia quando est\u00e3o juntas. Tamb\u00e9m chamado as vezes de teste de componente. Testes de ponta a ponta (End to End): Se comporta como um usu\u00e1rio usando a aplica\u00e7\u00e3o para verificar se tudo est\u00e1 funcionando corretamente. Tambem chamado as vezes de Teste funcional (Functional testing) ou e2e. Segundo o Trof\u00e9u dos testes, devemos ter mais testes de integra\u00e7\u00e3o do que unit\u00e1rios e isso se d\u00e1 muitas vezes porque n\u00e3o temos como ou n\u00e3o vale a pena testar de forma isolada um componente de UI, como um bot\u00e3o ou um input estilizado, por exemplo. Pense: N\u00e3o importa quantas propriedades o componente de bot\u00e3o ou input recebem. \u00c9 bom, se for poss\u00edvel, test\u00e1-los isoladamente, mas testar integrados com uma p\u00e1gina onde os bot\u00f5es e o input realmente ser\u00e3o utilizados vai nos dar muito mais confian\u00e7a nos testes e quem sabe at\u00e9 nem precisar\u00edamos nos preocupar com os testes unit\u00e1rios para esses componentes, hein? Talvez poder\u00edamos passar mais tempo escrevendo testes de integra\u00e7\u00e3o e criando menos mocks porque hoje eles seriam uma balan\u00e7a perfeita entre confian\u00e7a e velocidade/custo de desenvolvimento.","title":"Al\u00e9m dos testes unit\u00e1rios"},{"location":"10.%20Testes%20unitarios/#finalizando","text":"O assunto sobre testes \u00e9 de fato cheio de pol\u00eamicas. A linha que divide o que \u00e9 cada tipo de teste, saber o que testar, quando testar e qual ferramenta usar \u00e9 muito t\u00eanue e tudo isso gera muita d\u00favida e muita discuss\u00e3o. O fato \u00e9 que os testes devem nos dar confian\u00e7a para fazermos as altera\u00e7\u00f5es que precisarmos em nossa aplica\u00e7\u00e3o e garantindo que a aplica\u00e7\u00e3o continuar\u00e1 funcionando em produ\u00e7\u00e3o. N\u00e3o h\u00e1 d\u00favidas que essa \u00e9 a ess\u00eancia do teste de software.","title":"Finalizando"}]}